# Седмица 2: Двоични файлове. Позициониране във файлове.
*28.02.2017*

## План

* [Работа с двоични файлове](#Работа-с-двоични-файлове)
  * [Отваряне на поток](#Отваряне-на-поток)
    * [Типове на потоци](#Типове-на-потоци)
  * [Писане в двоичен файл](#Писане-в-двоичен файл)
  * [Четене от двоичен файл](#Четене-от-двоичен файл)
* [Позициониране във файл](#Позициониране-във-файл)
  * [Указатели за писане](#Указатели-за-писане)
  * [Указатели за четене](#Указатели-за-четене)
* [Състояние на файловия поток](#Състояние-на-файловия-поток)
* [Задачи](#Задачи)

## Работа с двоични файлове

### Отваряне на поток
[**^ План**](#План)

Двоичните файлове се отварят аналогично на обикновените с една разлика - указва
се, че става въпрос за двоичен файл (`ios::binary`) като втори аргумент:

```cpp
fstream binFile("file.bin", ios::binary);
```

По подразбиране отварянето на файл с `fstream` е както за писане, така и за
четене. Тъй като обаче се използва вторият параметър, то настъпва презаписване
на типа по подразбиране на отваряния файл и затова в допълнение трябва да се
добавят и `ios::in`, и `ios::out`. Т.е. успешният начин за отваряне на файл и за
четене, и за писане е:

```cpp
fstream binFile("file.bin", ios::binary | ios::in | ios::out);
```

А ако файлът не съществува, той няма да бъде създаден автоматично и трябва да се
добави `ios::trunc`, обаче трябва много да се внимава с това, тъй като ако има
вече съществуващ файл, той ще бъде напълно изтрит. Затова е хубаво да се
проверява. Това може да стане по най-различни начини, но следните две функции
вършат работа. Първата е най-простият възможне начин това да се направи, а
втората използва стандартизираната по
[POSIX стандарта](https://en.wikipedia.org/wiki/POSIX) функция `stat` и е около
4 пъти по-бърза, но изисква включването на библиотеката `<sys/stat.h>`:

```cpp
bool existsFile(const char* name) {
    ifstream f(name);
    return f.good();
}
```

Функцията `stat` има следната сигнатура:

```cpp
int stat(const char* path, struct stat* buf);
```
Може да прочете повече за `stat` 
[тук](http://pubs.opengroup.org/onlinepubs/9699919799/).

```cpp
bool existsFilePOSIX(const char* name) {
    struct stat buffer;   
    return (stat(name, &buffer) == 0); 
}
```

Това е валидно само за `fstream`, при `ifstream` и `ofstream` е необходимо само
упоменаването на `ios::binary` без да се допълва със `ios::in` и `ios::out`
съответно (все пак за консистентност и подсигуряване не е лошо да ги има), както
и без `ios::trunc` (освен ако това не е в изискванията).

![Suspicious Lana](http://68.media.tumblr.com/fc917e195370f596f5231d877c1fb133/tumblr_nx0jrmH2bs1uatuo9o1_500.gif)

Разбира се може и да се ползва разширеният запис - с методът (член-функция)
`open`, чиято сигнатура е:

```cpp
void open(const char *filename[, int mode][, int prot]);
```

Първият параметър очевидно е за името, вторият - за типа, а третият, който в
този курс няма да ни се налага да ползваме, е за права при многопотребителски
операционни системи като GNU/Linux и този параметър не се използва при Windows.

Отварянето на файл за четене и писане с `open` става по следния начин:
```cpp
fstream binFile;
binFile.open("file.bin", ios::binary | ios::in | ios::out);
```

#### Типове на потоци
[**^ План**](#План)

* `ios::in`: Указва, че потокът ще се използва за вход.
* `ios::out`: Указва, че потокът ще се използва за изход.
* `ios::ate`: Кара файловият указател да сочи в края на файла при отваряне на
  файл.
* `ios::trunc`: Изтрива цялата предишна информация в дадения файл с отварянето
  му.
* `ios::binary` Позволява файл да бъде достъпен като двоичен файл.

Могат да се комбинират с оператора за *побитово или*: `|`.

### Писане в двоичен файл
[**^ План**](#План)

За разлика от обикновените текстови файлове, при които писахме в тях с оператора
`<<`, както при стандартния изход `cout`, при двоичните файлове се налага
употребата на функцията:

```cpp
ostream& write(char* buffer, streamsize n);
```

Тази функция позволява **n** байта да бъдат записани от мястото от паметта, в
което е записан **buffer** във файл на диска и премества файловият указател
напред с **n** байта.

Записване на структури в двоичен файл става по следния начин:

*Пример:*
```cpp
#include <iostream>
#include <fstream>

struct Spy {
    char realName[16];
    int id;
};

int main() {
    std::ofstream spyFile("spies.bin", ios::binary);

    Spy spies[] = {{"Malory", 0},
                   {"Sterling", 1},
                   {"Lana", 2},
                   {"Pam", 3},
                   {"Cyril", 4}};

    // n - размер на масива, в случая sizeof(spies) / sizeof(spies[0])
    spyFile.write((char*)spies, n * sizeof(spies[0])); // за нединамичен масив може и направо sizeof(spies),
                                                       // вместо n * sizeof(spies[0])
    // или
    for (size_t i = 0; i < n; i++) {
        spyFile.write((char*)(spies + i), sizeof(spies[0]));
    }
    // или
    for (size_t i = 0; i < n; i++) {
        spyFile.write((char*)&spies[i], sizeof(Spy));
    }
    // или както по ви харесва, може и други комбинации, цикли, без цикли

    return 0;
}
```
![Krieger Jazz Hands](http://68.media.tumblr.com/95b3c1f33cf37e651750900b7972d7c6/tumblr_ns4omrJTuA1uatuo9o1_500.gif)

### Четене от двоичен файл
[**^ План**](#План)

За четенето от двоични файлове също има заделена специална функция със следната
сигнатура:

```cpp
istream& read(char* buffer, streamsize n);
```

Използва се аналогично на `write`, а ефектът от използването на `read` е, че
**buffer** съдържа прочетените **n** байта от отворения за четене файл и
съответно мести указателя за четене с **n** байта.

Тук вече не е добре да четем цял масив накуп, тъй като е добре да
проверяваме [състоянието на файловия поток](#Състояние-на-файловия-поток).

*Пример:*

```cpp
    std::ifstream spyFile("spies.bin", ios::binary);

    int n = 0;
    while (n <= 0) {
        std::cin >> n;
    }

    Spy* spies = new Spy[n];

    size_t i = 0;
    while(spyFile.good() && i < n) { // може да не се записва експлицитно spyFile.good(), а само spyFile,
                                     // т.е. цикълът ще се изпълнява, докато не са вдигнати нито 
                                     // ios::badbit, нито ios::failbit, нито ios::eofbit, и не се е
                                     // напълнил масива
        read((char *)(spies + i++), sizeof(spies[0]));
    }
    // или
    for (size_t i = 0; i < n && spyFile.good(); i++) {
        spyFile.write((char*)(spies + i), sizeof(Spy));
    }
    // или
    for (size_t i = 0; i < n && spyFile.good(); i++) {
        spyFile.write((char*)&spies[i], sizeof(spies[0]));
    }
```

## Позициониране във файл
[**^ План**](#План)

При отварянето на файл за четене или писане разполагате с файлов указател, с помощта на който четете или записвате от позицията, на който той се намира, нататък.
Можем да местим тези указатели из файла и с това да променяме определена част от даден файл, да добавяме или изтриваме съдържание.

Ако отваряме файл едновременно за писане и четене, то при местене на един от двата указателя (за четене и писане) и двата се преместват, т.е. може да си ги мислите като закачени един за друг (може да го мислите и като един указател), но когато ще пишете, то позиционирайте указателя за писане (`seekp(position)`), а при четене - указателя за четене (`seekg(position)`). Теоретично има шанс двата указателя да са на различна позиция във файла, но на практика това не е така.

И двете функции - за писане и за четене приемат два аргумента, вторият от които е незадължителен. Първият е отместването (по подразбиране от началото на файла), т.е. позиция във файловия поток, а с втория може да се зададе, дали отместването да е от:
* началото на файла (`std::ios::beg`, `stream.beg`);
* текущата позиция на указателя (`std::ios::cur`, `stream.cur`);
* края на файла (`std::ios::end`, `stream.end`).

`streampos` и `streamoff` може да ги мислите за `int`, просто се използват семантично за позиция и отстояние в поток, както `size_t` се използва за индексатор в масиви.

Действията прилагани и върху двата указателя са аналогични единствената разлика е *p*-то i *g*-то в имената на функциите, тях може да ги мислите като:
* *p* -> *put* -> писане;
* *g* -> *get* -> четене;

### Указател за писане
[**^ План**](#План)

```cpp
ostream& seekp(streampos pos);
ostream& seekp(streamoff off, std::ios::[beg|cur|end]);
```
Със `seekp` местите позицията на указателя за писане във файловия поток и следващият път, когато пишете с `write` ще започнете писането от позицията, която сте задали на указателя за писане.

```cpp
streampos tellp();
```
С `tellp` получаваме текущата позиция на указателя за писане.

### Указател за четене
[**^ План**](#План)

```cpp
istream& seekg(streampos pos);
istream& seekg(streamoff off, std::ios::[beg|cur|end]);
```
Със `seekg` местите позицията на указателя за четене във файловия поток и следващият път, когато четете с `read` ще започнете четенето от позицията, която сте задали на указателя за четене.

```cpp
streampos tellg();
```
С `tellg` получаваме текущата позиция на указателя за четене.

## Състояние на файловия поток
[**^ План**](#План)

## Задачи
[**^ План**](#План)
