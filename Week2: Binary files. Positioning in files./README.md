# Седмица 1: Структури. Работа с файлове.
*20.02.2017*

## План

* [Работа с двоични файлове](#)
  * [Отваряне на поток](#)
    * [Типове на потоци](#)
  * [Писане в двоичен файл](#)
  * [Четене от двоичен файл](#)
* [Позициониране във файл](#)
  * [Указатели за писане](#)
  * [Указатели за четене](#)
* [Състояние на файловия поток](#)
* [Задачи](#Задачи)

## Работа с двоични файлове

### Отваряне на поток
[**^ План**](#План)

Двоичните файлове се отварят аналогично на обикновените с една разлика - указва се, че става въпрос за двоичен файл (`ios::binary`) като втори аргумент:

```cpp
fstream binFile("file.bin", ios::binary);
```

По подразбиране отварянето на файл с `fstream` е както за писане, така и за четене. Тъй като обаче се използва вторият параметър, то настъпва презаписване на типа по подразбиране на отваряния файл и затова в допълнение трябва да се добавят и `ios::in`, и `ios::out`. Т.е. успешният начин за отваряне на файл и за четене, и за писане е:

```cpp
fstream binFile("file.bin", ios::binary | ios::in | ios::out);
```

А ако файлът не съществува, той няма да бъде създаден автоматично и трябва да се добави `ios::trunc`.

Това е валидно само за `fstream`, при `ifstream` и `ofstream` е необходимо единствено упоменаването на `ios::binary` без да се допълва със `ios::in` и `ios::out` съответно, както и `ios::trunc`.


Разбира се може и да се ползва разширеният запис - с методът (член-функция) `open`, чиято сигнатура е:

```cpp
void open(const char *filename[, int mode][, int prot]);
```

Първият параметър очевидно е за името, вторият - за типа, а третият, който в този курс няма да ни се налага да ползваме, е за права при многопотребителски операционни системи като GNU/Linux и този параметър не се използва при Windows.

Отварянето на файл за четене и писане с `open` става по следния начин:
```cpp
fstream binFile;
binFile.open("file.bin", ios::binary | ios::in | ios::out);
```

#### Типове на потоци
[**^ План**](#План)

* `ios::in`: Указва, че потокът ще се използва за вход.
* `ios::out`: Указва, че потокът ще се използва за изход.
* `ios::ate`: Кара файловият указател да сочи в края на файла при отваряне на
  файл.
* `ios::trunc`: Изтрива цялата предишна информация в дадения файл с отварянето
  му.
* `ios::binary` Позволява файл да бъде достъпен като двоичен файл.

### Писане в двоичен файл
[**^ План**](#План)

За разлика от обикновените текстови файлове, при които писахме в тях с оператора
`<<`, както при стандартния изход `cout`, при двоичните файлове се налага
употребата на функцията:

```cpp
ostream& write(const char* buffer, streamsize n);
```

Тази функция позволява **n** байта да бъдат записани от мястото от паметта, в
което е записан **buffer** във файл на диска и премества файловият указател
напред с **n** байта.

Записване на структури в двоичен файл става по следния начин:

*Пример:*
```cpp
#include <iostream>
#include <fstream>

struct Spy {
    char realName[16];
    int id;
};

int main() {
    std::fstream spyFile("spies.bin", ios::binary | ios::in | ios::out);

    Spy spies[] = {{"Malory", 0},
                   {"Archer", 1},
                   {"Lana", 2},
                   {"Pam", 3},
                   {"Cyril", 4}};

    // n - размер на масива (за нединамичен масив може и направо sizeof(spies))

    spyFile.write((char*)spies, n * sizeof(spies[0])); 
    // или
    for (size_t i = 0; i < n; i++) {
        spyFile.write((char*)(spies + i), sizeof(Spy));
    }
    // или
    for (size_t i = 0; i < n; i++) {
        spyFile.write((char*)&spies[i], sizeof(Spy));
    }

    return 0;
}
```

### Четене от двоичен файл
[**^ План**](#План)

## Позициониране във файл
[**^ План**](#План)

### Указател за писане
[**^ План**](#План)

### Указател за четене
[**^ План**](#План)

## Състояние на файловия поток
[**^ План**](#План)

## Задачи
[**^ План**](#План)
