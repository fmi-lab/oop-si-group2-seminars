# Седмица 2: Двоични файлове. Позициониране във файлове.
*28.02.2017*

## План

* [Работа с двоични файлове](#Работа-с-двоични-файлове)
  * [Отваряне на поток](#Отваряне-на-поток)
    * [Типове на потоци](#Типове-на-потоци)
  * [Писане в двоичен файл](#Писане-в-двоичен файл)
  * [Четене от двоичен файл](#Четене-от-двоичен файл)
* [Позициониране във файл](#Позициониране-във-файл)
  * [Указатели за писане](#Указатели-за-писане)
  * [Указатели за четене](#Указатели-за-четене)
* [Състояние на файловия поток](#Състояние-на-файловия-поток)
* [Задачи](#Задачи)

## Работа с двоични файлове

### Отваряне на поток
[**^ План**](#План)

Двоичните файлове се отварят аналогично на обикновените с една разлика - указва
се, че става въпрос за двоичен файл (`ios::binary`) като втори аргумент:

```cpp
fstream binFile("file.bin", ios::binary);
```

По подразбиране отварянето на файл с `fstream` е както за писане, така и за
четене. Тъй като обаче се използва вторият параметър, то настъпва презаписване
на типа по подразбиране на отваряния файл и затова в допълнение трябва да се
добавят и `ios::in`, и `ios::out`. Т.е. успешният начин за отваряне на файл и за
четене, и за писане е:

```cpp
fstream binFile("file.bin", ios::binary | ios::in | ios::out);
```

А ако файлът не съществува, той няма да бъде създаден автоматично и трябва да се
добави `ios::trunc`, обаче трябва много да се внимава с това, тъй като ако има
вече съществуващ файл, той ще бъде напълно изтрит. Затова е хубаво да се
проверява. Това може да стане по най-различни начини, но следните две функции
вършат работа. Първата е най-простият възможне начин това да се направи, а
втората използва стандартизираната по
[POSIX стандарта](https://en.wikipedia.org/wiki/POSIX) функция `stat` и е около
4 пъти по-бърза, но изисква включването на библиотеката `<sys/stat.h>`:

```cpp
bool existsFile (const char* name) {
    ifstream f(name);
    return f.good();
}
```

Функцията `stat` има следната сигнатура:

```cpp
int stat(const char *restrict path, struct stat *restrict buf);
```
Може да прочете повече за `stat` 
[тук](http://pubs.opengroup.org/onlinepubs/9699919799/).

```cpp
bool existsFilePOSIX (const char* name) {
    struct stat buffer;   
    return (stat (name, &buffer) == 0); 
}
```

Това е валидно само за `fstream`, при `ifstream` и `ofstream` е необходимо
единствено упоменаването на `ios::binary` без да се допълва със `ios::in` и
`ios::out` съответно, както и без `ios::trunc`.

![Suspicious Lana](http://68.media.tumblr.com/fc917e195370f596f5231d877c1fb133/tumblr_nx0jrmH2bs1uatuo9o1_500.gif)

Разбира се може и да се ползва разширеният запис - с методът (член-функция)
`open`, чиято сигнатура е:

```cpp
void open(const char *filename[, int mode][, int prot]);
```

Първият параметър очевидно е за името, вторият - за типа, а третият, който в
този курс няма да ни се налага да ползваме, е за права при многопотребителски
операционни системи като GNU/Linux и този параметър не се използва при Windows.

Отварянето на файл за четене и писане с `open` става по следния начин:
```cpp
fstream binFile;
binFile.open("file.bin", ios::binary | ios::in | ios::out);
```

#### Типове на потоци
[**^ План**](#План)

* `ios::in`: Указва, че потокът ще се използва за вход.
* `ios::out`: Указва, че потокът ще се използва за изход.
* `ios::ate`: Кара файловият указател да сочи в края на файла при отваряне на
  файл.
* `ios::trunc`: Изтрива цялата предишна информация в дадения файл с отварянето
  му.
* `ios::binary` Позволява файл да бъде достъпен като двоичен файл.

Могат да се комбинират с оператора за *побитово или*: `|`.

### Писане в двоичен файл
[**^ План**](#План)

За разлика от обикновените текстови файлове, при които писахме в тях с оператора
`<<`, както при стандартния изход `cout`, при двоичните файлове се налага
употребата на функцията:

```cpp
ostream& write(char* buffer, streamsize n);
```

Тази функция позволява **n** байта да бъдат записани от мястото от паметта, в
което е записан **buffer** във файл на диска и премества файловият указател
напред с **n** байта.

Записване на структури в двоичен файл става по следния начин:

*Пример:*
```cpp
#include <iostream>
#include <fstream>

struct Spy {
    char realName[16];
    int id;
};

int main() {
    std::ofstream spyFile("spies.bin", ios::binary);

    Spy spies[] = {{"Malory", 0},
                   {"Sterling", 1},
                   {"Lana", 2},
                   {"Pam", 3},
                   {"Cyril", 4}};

    // n - размер на масива 

    spyFile.write((char*)spies, n * sizeof(spies[0])); // за нединамичен масив може и направо sizeof(spies),
                                                       // вместо n * sizeof(spies[0])
    // или
    for (size_t i = 0; i < n; i++) {
        spyFile.write((char*)(spies + i), sizeof(spies[0]));
    }
    // или
    for (size_t i = 0; i < n; i++) {
        spyFile.write((char*)&spies[i], sizeof(Spy));
    }

    return 0;
}
```
![Krieger Jazz Hands](http://68.media.tumblr.com/95b3c1f33cf37e651750900b7972d7c6/tumblr_ns4omrJTuA1uatuo9o1_500.gif)

### Четене от двоичен файл
[**^ План**](#План)

За четенето от двоични файлове също има заделена специална функция със следната
сигнатура:

```cpp
istream& read (char* buffer, streamsize n);
```

Използва се аналогично на `write`, а ефектът от използването на `read` е, че
**buffer** съдържа прочетените **n** байта от отворения за четене файл и
съответно мести указателя за четене с **n** байта.

Тук вече не е добре да четем цял масив накуп, тъй като е добре да
проверяваме [състоянието на файловия поток](#Състояние-на-файловия-поток).

*Пример:*

```cpp
    std::ifstream spyFile("spies.bin", ios::binary);

    int n = 0;
    while (n <= 0) {
        cin >> n;
    }

    Spy* spies = new Spy[n];

    size_t i = 0;
    while(spyFile.good() && i < n) { // може да не се записва експлицитно spyFile.good(), а само spyFile,
                                     // т.е. цикълът ще се изпълнява, докато не са вдигнати нито 
                                     // ios::badbit, нито ios::failbit, нито ios::eofbit, и не се е
                                     // напълнил масива
        read((char *)(spies + i++), sizeof(spies[0]));
    }
    // или
    for (size_t i = 0; i < n && spyFile.good(); i++) {
        spyFile.write((char*)(spies + i), sizeof(Spy));
    }
    // или
    for (size_t i = 0; i < n && spyFile.good(); i++) {
        spyFile.write((char*)&spies[i], sizeof(spies[0]));
    }
```

## Позициониране във файл
[**^ План**](#План)

### Указател за писане
[**^ План**](#План)

### Указател за четене
[**^ План**](#План)

## Състояние на файловия поток
[**^ План**](#План)

## Задачи
[**^ План**](#План)
