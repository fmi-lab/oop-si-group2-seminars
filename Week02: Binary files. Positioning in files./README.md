# Седмица 2: Двоични файлове. Позициониране във файлове.
*28.02.2017*

## План

* [Работа с двоични файлове](#Работа-с-двоични-файлове)
  * [Отваряне на поток](#Отваряне-на-поток)
    * [Типове на потоци](#Типове-на-потоци)
  * [Писане в двоичен файл](#Писане-в-двоичен файл)
  * [Четене от двоичен файл](#Четене-от-двоичен файл)
* [Позициониране във файл](#Позициониране-във-файл)
  * [Указатели за писане](#Указатели-за-писане)
  * [Указатели за четене](#Указатели-за-четене)
* [Състояние на файловия поток](#Състояние-на-файловия-поток)
* [Задачи](#Задачи)

## Работа с двоични файлове

### Отваряне на поток
[**^ План**](#План)

Двоичните файлове се отварят аналогично на обикновените с една разлика - указва
се, че става въпрос за двоичен файл (`std::ios::binary`) като втори аргумент:

```cpp
std::fstream binFile("file.bin", std::ios::binary);
```

По подразбиране отварянето на файл с `fstream` е както за писане, така и за
четене. Тъй като обаче се използва вторият параметър, то настъпва презаписване
на типа по подразбиране на отваряния файл и затова в допълнение трябва да се
добавят и `std::ios::in`, и `std::ios::out`. Т.е. успешният начин за отваряне на файл и за
четене, и за писане е:

```cpp
std::fstream binFile("file.bin", std::ios::binary | std::ios::in | std::ios::out);
```

А ако файлът не съществува, той няма да бъде създаден автоматично и трябва да се
добави `std::ios::trunc`, обаче трябва много да се внимава с това, тъй като ако има
вече съществуващ файл, той ще бъде напълно изтрит. Затова е хубаво да се
проверява. Това може да стане по най-различни начини, но следните две функции
вършат работа. Първата е най-простият възможне начин това да се направи, а
втората използва стандартизираната по
[POSIX стандарта](https://en.wikipedia.org/wiki/POSIX) функция `stat` и е около
4 пъти по-бърза, но изисква включването на библиотеката `<sys/stat.h>`:

```cpp
bool existsFile(const char* name) {
    ifstream f(name);
    return f.good();
}
```

Функцията `stat` има следната сигнатура:

```cpp
int stat(const char* path, struct stat* buf);
```
Може да прочете повече за `stat` 
[тук](http://pubs.opengroup.org/onlinepubs/9699919799/).

```cpp
bool existsFilePOSIX(const char* name) {
    struct stat buffer;   
    return (stat(name, &buffer) == 0); 
}
```

Това е валидно само за `fstream`, при `ifstream` и `ofstream` е необходимо само
упоменаването на `std::ios::binary` без да се допълва със `std::ios::in` и `std::ios::out`
съответно (все пак за консистентност и подсигуряване не е лошо да ги има), както
и без `std::ios::trunc` (освен ако това не е в изискванията).

![Suspicious Lana](http://68.media.tumblr.com/fc917e195370f596f5231d877c1fb133/tumblr_nx0jrmH2bs1uatuo9o1_500.gif)

Разбира се може и да се ползва разширеният запис - с методът (член-функция)
`open`, чиято сигнатура е:

```cpp
void open(const char *filename[, int mode][, int prot]);
```

Първият параметър очевидно е за името, вторият - за типа, а третият, който в
този курс няма да ни се налага да ползваме, е за права при многопотребителски
операционни системи като GNU/Linux и този параметър не се използва при Windows.

Отварянето на файл за четене и писане с `open` става по следния начин:
```cpp
std::fstream binFile;
binFile.open("file.bin", std::ios::binary | std::ios::in | std::ios::out);
```

#### Типове на потоци
[**^ План**](#План)

* `std::ios::in`: Указва, че потокът ще се използва за вход.
* `std::ios::out`: Указва, че потокът ще се използва за изход.
* `std::ios::ate`: Кара файловият указател да сочи в края на файла при отваряне на
  файл.
* `std::ios::trunc`: Изтрива цялата предишна информация в дадения файл с отварянето
  му.
* `std::ios::binary` Позволява файл да бъде достъпен като двоичен файл.

Могат да се комбинират с оператора за *побитово или*: `|`.

### Писане в двоичен файл
[**^ План**](#План)

За разлика от обикновените текстови файлове, при които писахме в тях с оператора
`<<`, както при стандартния изход `std::cout`, при двоичните файлове се налага
употребата на функцията:

```cpp
ostream& write(char* buffer, streamsize n);
```

Тази функция позволява **n** байта да бъдат записани от мястото от паметта, в
което е записан **buffer** във файл на диска и премества файловият указател
напред с **n** байта.

Записване на структури в двоичен файл става по следния начин:

*Пример:*
```cpp
#include <iostream>
#include <fstream>

struct Spy {
    char realName[16];
    int id;
};

int main() {
    std::ofstream spyFile("spies.bin", std::ios::binary);

    Spy spies[] = {{"Malory", 0},
                   {"Sterling", 1},
                   {"Lana", 2},
                   {"Pam", 3},
                   {"Cyril", 4}};

    // n - размер на масива, в случая sizeof(spies) / sizeof(spies[0])
    spyFile.write((char*)spies, n * sizeof(spies[0])); // за нединамичен масив може и направо sizeof(spies),
                                                       // вместо n * sizeof(spies[0])
    // по-добре е експлицитно да се използва reinterpret_cast<char*>(spies)
    spyFile.write(reinterpret_cast<char*>(spies), n * sizeof(spies[0]));
    // или
    for (size_t i = 0; i < n; i++) {
        spyFile.write(reinterpret_cast<char*>(spies + i), sizeof(spies[0]));
    }
    // или
    for (size_t i = 0; i < n; i++) {
        spyFile.write(reinterpret_cast<char*>(&spies[i]), sizeof(Spy));
    }
    // или както по ви харесва, може и други комбинации, цикли, без цикли

    spyFile.close();

    return 0;
}
```
![Krieger Jazz Hands](http://68.media.tumblr.com/95b3c1f33cf37e651750900b7972d7c6/tumblr_ns4omrJTuA1uatuo9o1_500.gif)

### Четене от двоичен файл
[**^ План**](#План)

За четенето от двоични файлове също има заделена специална функция със следната
сигнатура:

```cpp
istream& read(char* buffer, streamsize n);
```

Използва се аналогично на `write`, а ефектът от използването на `read` е, че
**buffer** съдържа прочетените **n** байта от отворения за четене файл и
съответно мести указателя за четене с **n** байта.

Тук вече не е добре да четем цял масив накуп, тъй като е добре да
проверяваме [състоянието на файловия поток](#Състояние-на-файловия-поток).

*Пример:*

```cpp
#include <iostream>
#include <fstream>

struct Spy {
    char realName[16];
    int id;
};

int main() {

    std::ifstream spyFile("spies.bin", std::ios::binary);

    int n = 0;
    while (n <= 0) {
        std::cin >> n;
    }

    Spy* spies = new Spy[n];

    size_t i = 0;
    while(spyFile.good() && i < n) { // може да не се записва експлицитно spyFile.good(), а само spyFile,
                                     // т.е. цикълът ще се изпълнява, докато не са вдигнати никой от
                                     // битовете std::ios::badbit, std::ios::failbit и std::ios::eofbit, 
                                     // и не се е напълнил масива
        spyFile.read(reinterpret_cast<char*>(spies + i++), sizeof(spies[0]));
    }
    // или
    for (size_t i = 0; i < n && spyFile.good(); i++) {
        spyFile.read(reinterpret_cast<char*>(spies + i), sizeof(Spy));
    }
    // или
    for (size_t i = 0; i < n && spyFile.good(); i++) {
        spyFile.read(reinterpret_cast<char*>(&spies[i]), sizeof(spies[0]));
    }

    spyFile.close();

    return 0;
}
```

![Krieger Jazz Hands](http://68.media.tumblr.com/95b3c1f33cf37e651750900b7972d7c6/tumblr_ns4omrJTuA1uatuo9o1_500.gif)

## Позициониране във файл
[**^ План**](#План)

При отварянето на файл за четене или писане разполагате с файлов указател, с
помощта на който четете или записвате от позицията, на който той се намира,
нататък.  Можем да местим тези указатели из файла и с това да променяме
определена част от даден файл, да добавяме или изтриваме съдържание.

Ако отваряме файл едновременно за писане и четене, то при местене на един от
двата указателя (за четене и писане) и двата се преместват, т.е. може да си ги
мислите като закачени един за друг (може да го мислите и като един указател), но
когато ще пишете, то позиционирайте указателя за писане (`seekp(position)`), а
при четене - указателя за четене (`seekg(position)`). Теоретично има шанс двата
указателя да са на различна позиция във файла, но на практика това не е така.

И двете функции - за писане и за четене приемат два аргумента, вторият от които
е незадължителен. Първият е отместването (по подразбиране от началото на файла),
т.е. позиция във файловия поток, а с втория може да се зададе, дали отместването
да е от:
* началото на файла (`std::ios::beg`, `stream.beg`);
* текущата позиция на указателя (`std::ios::cur`, `stream.cur`);
* края на файла (`std::ios::end`, `stream.end`).

`streampos` и `streamoff` може да ги мислите за `int`, просто се използват
семантично за позиция и отстояние в поток, както `size_t` се използва за
индексатор в масиви.

Действията прилагани и върху двата указателя са аналогични единствената разлика
е *p*-то i *g*-то в имената на функциите, тях може да ги мислите като:
* *p* -> *put* -> писане;
* *g* -> *get* -> четене;

### Указател за писане
[**^ План**](#План)

```cpp
ostream& seekp(streampos pos);
ostream& seekp(streamoff off, std::ios::[beg|cur|end]);
```
Със `seekp` местите позицията в байтове на указателя за писане във файловия
поток и следващият път, когато пишете с `write` ще започнете писането от
позицията, която сте задали на указателя за писане.

```cpp
streampos tellp();
```
С `tellp` получаваме текущата позиция на указателя за писане.

### Указател за четене
[**^ План**](#План)

```cpp
istream& seekg(streampos pos);
istream& seekg(streamoff off, std::ios::[beg|cur|end]);
```
Със `seekg` местите позицията в байтове на указателя за четене във файловия
поток и следващият път, когато четете с `read` ще започнете четенето от
позицията, която сте задали на указателя за четене.

```cpp
streampos tellg();
```
С `tellg` получаваме текущата позиция на указателя за четене.

## Състояние на файловия поток
[**^ План**](#План)

Всеки файл има асоциирани четири бита (флагове) за състояние на файл:
* `std::ios::goodbit` - не е възникнала грешка, операциите са изпълнени успешно;
* `std::ios::failbit` - възникнала е формaтна грешка или входната операция не е
  успешна. Няма загубени данни, но следващата операция с потока не може да се
  извърши, въпреки това състоянието на потока може да се възстанови.
* `std::ios::eofbit` - достигнат е краят на файла, влече активирането и на
  `std::ios::failbit`;
* `std::ios::badbit` - изпълнена е невалидна операция или при входна операция
  част от информацията е загубена. Следваща операция с потока не може да се
  извърши и състоянието на потока не може да бъде възстановено, тъй като той се
  разрушава. Активира и `std::ios::failbit`.

Всеки поток има булев метод (член-функция) за състояние, чиито имена съответсват
на горе изброените състояния:
* `good()`;
* `fail()`;
* `eof()`;
* `bad()`.

Всеки от тези методи връща истина, когато битът със съответното име е активиран
и лъжа - в противен случай. Единствено за `good()` да върне истина, допълнително
изискване е никой от останалите битове да не бъде активиран. Прилагането на
операция върху поток, за който `good()` връща лъжа, е празна операция.

```cpp
iostate rdstate() const;
```
Връща число в десетична бройна система отговарящо на състоянието на флаговете
std::ios::failbit, std::ios::eofbit и std::ios::badbit в тази поредност. При
доборо състояние на файловия поток, това е 000, следователно `stream.rdstate()`
е равен на 0, когато `stream.good()` връща истина.

```cpp
void clear([iostate flag]);
```
Нулира всички флагове на файловия поток, като след това активира *flag* бита. По
подразбиране *flag* е равен на `std::ios::goodbit`. Може да се използва побитова
аритметика, за да се променят активираните битове.

*Пример:*

```cpp
std::fstream spyFile("spyFile.bin", std::ios::binary | std::ios::in | std::ios::out);

std::cout << spyFile.rdstate() << std::endl; // Връща 0, тъй като всички битове освен std::ios::goodbit
                                             // са в изначална позиция и са занулени

Spy spy;
while (spyFile) {
    spyFile.read(reinterpret_cast<char*>(&spy), sizeof(spy));
}

std::cout << spyFile.rdstate() << std::endl; // Връща 6, тъй като std::ios::eofbit и std::ios::failbit са 
                                             // активирани и имаме следното двоично число 110 
                                             // еквивалентно на 6 в десетична бройна система

spyFile.clear(); // Изчистваме всички битове и активираме std::ios::goodbit

std::cout << spyFile.rdstate() << std::endl; // Връща 0, тъй като всички битове освен std::ios::goodbit
                                             // са в изначална позиция и са занулени

spyFile.clear(std::ios::failbit); // Изчистваме всички битове и активираме std::ios::failbit

std::cout << spyFile.rdstate() << std::endl; // Връща 4, тъй като std::ios::failbit е
                                             // активиран и имаме следното двоично число 010 
                                             // еквивалентно на 4 в десетична бройна система

spyFile.clear(~std::ios::failbit & spyFile.rdstate()); // Обръщаме състоянието на std::ios::failbit

std::cout << spyFile.rdstate() << std::endl; // Връща 0, тъй като всички битове освен std::ios::goodbit
                                             // са в изначална позиция и са занулени
spyFile.close();
```

## Задачи
[**^ План**](#План)

1. Да се дефинира структура Planet, определяща планета по име (символен низ), разстояние от слънцето, диаметър и маса (реални числа). Да се дефинират функции, изпълняващи следните действия:
  * въвежда данни за планета от клавиатура;
  * извежда данните за планета;
  * записва планета в двоичен файл;
  * връща като резултат броя секунди, които са необходими на светлината да достигне от слънцето до планетата (да се приеме, че светлината има скорост 299792 km/s и че разстоянието на планетата до слънцето е зададено в километри;
  * въвежда от двоичен файл множество от планети (да се реализира чрез едномерен масив);
  * извежда данните за планетите от масив, подаден на функцията като параметър;
  * отпечатва данните за планетата с най-голям диаметър от масив, подаден на функцията като параметър.

2. Да се напише програма, която чете от двоичен файл редица от тройки от реални числа, представящи коефициенти на квадратни уравнения. Програмата да намира корените на дефинираните квадратни уравнения и да ги запише в текстов файл - за всяко уравнение на отделен ред. Ако уравнение няма реални корени или не е квадратно да се запише "XXX".

