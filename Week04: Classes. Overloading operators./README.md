# Седмица 4: Класове. Голямата четворка. Предефиниране на оператори.
*13.03.2017*

## План

* [Принципи на обектно ориентираното програмиране]()
  * [Енкапсулация](#Енкапсулация)
    * [Селектори](#Селектори)
    * [Мутатори](#Мутатори)
  * [Абстракция с данни](#Абстракция-с-данни)
  * [Наследяване](#Наследяване)
  * [Полиморфизъм](#Полиморфизъм)
* [Класове](#Класове)
  * [Разлики между класове и структури](#Разлики-между-класове-и-структури)
  * [Организация на файловете](#Организация-на-файловете)
    * [Заглавни файлове](#Заглавни-файлове)
    * [Изходни файлове](#Изходни-файлове)
  * [Спецификатори за достъп](#Спецификатори-за-достъп)
    * [public](#public)
    * [protected](#protected)
    * [private](#private)
* [Предефиниране на оператори](#Предефиниране-на-оператори)
  * [Приятелски функции](#Приятелски-функции)
  * [Оператор за присвояване](#Оператор-за-присвояване)
  * [Аритметични оператори](#Аритметични-оператори)
    * [Съставни оператори](#Съставни-оператори)
  * [Оператори за сравнение](#Оператори-за-сравнение)
  * [Оператори за извеждане и въвеждане](#Оператори-за-извеждане-и-въвеждане)
  * [Оператори за индексиране](#Оператори-за-индексиране)
* [Задачи](#Задачи)

## Принципи на обектно-ориентираното програмиране
[**^ План**](#План)

### Енкапсулация
[**^ План**](#План)

За околният свят на даден обект не трябва да е възможно достъп до член-данните
му, т.е. разделя се описанието (интерфейса) на класа от конкретната му
реализация. Това позволява променянето на реализацията при нужда запазвайки
интерфейса на класа.

#### Селектори
[**^ План**](#План)

Селекторите са член-функции позволяващи преглед на член-данните, без
да ги променят. Обикновено са константни, за да се покаже експлицитно, че
промяна няма да има. Getter-ите са такива член-функции, които връщат стойността
на конкретна член-данна. Getter-ите са селектори, но не всички селектори са
getter-и, т.е. всяка публична член-функция даваща информация за състоянието на
текущия обект може да се нарече селектор.

#### Мутатори
[**^ План**](#План)

Мутаторите (setter-и) са член-функции позволяващи промяна на член-данните като
скриват как точно променят член-данните.

### Абстракция с данни
[**^ План**](#План)

Абстракцията с данни и енкапсулацията са много тясно свързани, тъй като
абстракцията с най-прости думи е създаването на класове и типове спрямо техните
интерфейси и функционалности, а не спрямо имлементационните им детайли, т.е.
един софтуерен обект всъщност да е модел на обект от реалния свят и да притежава
минимум основните характеристики и възможности на този обект.

### Наследяване
[**^ План**](#План)

### Полиморфизъм
[**^ План**](#План)

## Класове
[**^ План**](#План)

### Разлики между класове и структури
[**^ План**](#План)

* Класовете по продразбиране са капсулирани (спецификаторът за достъп в тялото е
  [private](#private), докато на структурата е [public](#public))

*Offtopic:* Както стана ясно в предното упражнение, ключовата дума `class` е
използвана в миналото за деклариране на шаблони, а `struct` не.

### Организация на файловете
[**^ План**](#План)

#### Заглавни файлове (*.h)
[**^ План**](#План)

Интерфейсът на класа се записва във заглавен (header) файл. Това включва
дефиниции на структури и класове, декларации на функции и методи. Включват се и
полетата на типа, тъй като компилаторът трябва да знае колко памет замеат
променливите от дефинирания тип, за да може да определи пълният размер на типа.

Интерфейсът на класа трябва да се загради с "include guards": `#ifndef
<име_на_клас> #define <име_на_клас> #endif`, което служи за избягване на
повторно включване на даден клас в програмата, а оттам и грешка. Може да се
използва и `#pragma once` в Windows. [Header
Guidelines](http://www.umich.edu/~eecs381/handouts/CppHeaderFileGuidelines.pdf)

#### Изходни файлове (*.cpp)
[**^ План**](#План)

Имплементацията на класа се записва в изходен (source) файл. Включва се
заглавният файл `#include "<име_на_клас>.h"` - използват се кавички, а не
счупени скоби, тъй като по този начин компилаторът тръгва да търси включеният
файл от текущата директори нагоре, а със счупените скоби директно търси в
системните файлове.

---

*Забележка:* При шаблонните класове има особеност при разделянето на интерфейса
от имплементацията: [Why can’t I separate the definition of my templates class
from its declaration and put it inside a .cpp
file?](https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl). Често
използвано решение е да се използва файл с разширение .tpp за имплементацията и
той да бъде включен в края на заглавния файл.

### Спецификатори за достъп
[**^ План**](#План)

#### public
[**^ План**](#План)

Методите (член-функциите) могат да бъдат достъпвани от външни програми чрез
инстанция на класа (обект).

#### protected
[**^ План**](#План)

Член-данните и методите (член-функциите) могат да бъдат достъпвани извън класа,
но само от негови наследници (и то при public/protected наследяване).

#### private
[**^ План**](#План)

Член-данните и методите (член-функциите) могат да бъдат достъпвани само от
методите на типа.

## Предефиниране на оператори 
[**^ План**](#План)

Можем да си напишем член-функции на даден клас, които да вършат работата по
сравнение, извеждане, въвеждане, индексиране и така нататък, но при положение,
че има вече съществуващи такива е по-добре просто да предефинираме действието
им. Така дори инстанция на нашия клас започва да има една много по-интуитивна
употреба. Затова ще предефинираме (overload) различни оператори.

Нека имаме клас X.

```cpp
class X {
// ...
};
```
### Приятелски функции
[**^ План**](#План)

Приятелските функции са такива функции, които имат достъп до protected и privat
компонентите на класа, на който са „приятели“.

### Оператор за присвояване
[**^ План**](#План)

*Сигнатура:* 

```cpp
X& X::operator=(const X& rhs);
```
* Подава се като аргумент константен псевдоним (дясната страна на инициализацията);
* Връща се псевдоним от лявата страна (прави се, за да се поддържа навръзване,
  т.е. a = b = c = d);
* Трябва да се направи проверка, дали `*this` и rhs не са един и същ обект.

```cpp
X& X::operator=(const X& rhs) {
    if (this != &rhs) {
    }

    return *this;
}
```

### Съставни оператори
[**^ План**](#План)

*Сигнатура:*

```cpp
X& X::operator+=(const X& rhs);
```
```cpp
X& X::operator+=(const X& rhs) {
    // модификация на *this, реализация на събирането на член-данните на двата
    // обекта

    return *this;
}
```

### Аритметични оператори
[**^ План**](#План)

```cpp
friend X operator+(X lhs, const X &rhs);
```

```cpp
X operator+(X lhs, const X& rhs) {
    // използваме вече дефинираният оператор +=
    lhs += rhs;
    return lhs;
}
```

### Оператори за сравнение
[**^ План**](#План)

Тези оператори е хубаво да се имплементират като приятелски (или inline)
функции, също така предефинира ли се един от тях е добре всички останали да
бъдат включени, тъй като се очаква от потребителя щом може да разполага с един,
то и останалите да са налице. Реално е необходима имплементация на два от
операторите, останалите просто ги използват.

*Сигнатура:*

```cpp
friend bool operator==(const X& lhs, const X& rhs);
friend bool operator!=(const X& lhs, const X& rhs);
friend bool operator< (const X& lhs, const X& rhs);
friend bool operator> (const X& lhs, const X& rhs);
friend bool operator<=(const X& lhs, const X& rhs);
friend bool operator>=(const X& lhs, const X& rhs);
```

```cpp
bool operator==(const X& lhs, const X& rhs){ /* необходима имплементация */ }
bool operator!=(const X& lhs, const X& rhs){ return !operator==(lhs,rhs);}
bool operator< (const X& lhs, const X& rhs){ /* необходима имплементация */ }
bool operator> (const X& lhs, const X& rhs){ return  operator< (rhs,lhs); }
bool operator<=(const X& lhs, const X& rhs){ return !operator> (lhs,rhs); }
bool operator>=(const X& lhs, const X& rhs){ return !operator< (lhs,rhs); }
```

### Оператори за извеждане и въвеждане
[**^ План**](#План)

```cpp
friend std::ostream& operator<<(std::ostream& os, const X& obj);
friend std::istream& operator>>(std::istream& is, X& obj)
```

```cpp
std::ostream& operator<<(std::ostream& os, const X& obj)
{
    // извеждане на обекта  
    return os;
}

std::istream& operator>>(std::istream& is, X& obj)
{
    // четене на обекта

    if( /* неуспешно четене на обекто от тип X*/ )
        is.setstate(std::ios::failbit);

    return is;
}
```

### Оператори за индексиране
[**^ План**](#План)

Трябва да са дефинирани като член-функции на дадения клас. Използват се за
типове-контейнери, които под някаква форма държат поредица от елементи и
позволяват достъп до тях чрез някакъв ключ/индекс.

```cpp
value_type& operator[](index_type idx);
const value_type& operator[](index_type idx) const;
```

## Задачи 

1. Стек е редица от 0 или повече елементи, в която включването и изключването на елемент се осъществява в единия край на редицата (върха на стека). Да се дефинира клас, който създава стек от символи.
2. Горният клас да се направи шаблонен, т.е. да не може да държи не само символи.
