# Седмица 1: Работа с файлове
*20.02.2017*

## Преговор

### Работа със масиви от символи

### Структури

Конвенцията за именуването на структурите е имената им да са изписани в CamelCase (т.е. започва се с главна буква и ако името е по-дълго от една дума, то всяка следваща дума се залепя за предходната като първата ѝ буква е главна).

Представете си структурите като контейнери, които съдържат по няколко полета. Пример за контейнер е „точка“, тя в зависимост от това дали е в двумерното или тримерното пространство има две или три полета -- нейните координати по x и y или x, y и z.

Структурите, ако се ползват е най-добре да се използват в най-простият им вид, т.е. като контейнер за няколко променливи, тъй като ако се започне разширяване с различни член-функции (методи) по-добре да се използва клас.

Член-данните на структурата са достъпни отвън по подразбиране (т.е. са public). Това означава, че след като се създаде някакъв обект от тази структура, то неговите полета могат да се достъпят директно с оператора „точка“.

*Пример:* 
```cpp
struct 2DPoint
{
    double x;
    double y;
};

2DPoint point = {0, 0}; 
```
То, в такъв случай `std::cout << "(" << point.x << ", " << point.y << ")" << std::endl;` ще изведе на екрана `(0, 0)`. Това противоречи с един от основните принципи на обектно-ориентираното програмиране, а именно енкапсуалцията на данни, т.е. скриването на вътрешната имплементация от потребителя. Разбира се, и при структурите бихме могли да сложим спецификаторът за достъп `private` за тези член-данни и да използваме член-функции за достъп и работа с тях, но тогава отново е по-добре да се
използват класове. Като цяло структурите са подходящи в частни случаи, когато биха могли да се използват при структури от данни и това би улеснило имплементацията. 

Защо тогава има и структури и класове в C++? Най-очевидното обяснение е, че тъй като C++ е наследник на C, то в C няма концепция за обектно-ориентирано програмиране, такова разбира се би могло да се симулира (["Object-oriented Programming in ANSI-C" -- Axel Schreiner](https://www.cs.rit.edu/~ats/books/ooc.pdf)), но тъй като самите структури нямат конструктури и деструктури, то е необходима допълнителна грижа. В C++ класовете предоставят по-разширени възможности в сравнение със структурите,
но те лежат на една основа. Принципно в C++ обичайно употребата на клас вместо структура е по-добрия избор.

Структури могат да имат за член-данни променливи от тип на друга структура.  

*Пример:* 
```cpp
struct Circle
{
    double radius;
    2DPoint center;
};

```

В случай обаче, че този тип всъщност е типа на текущо дефинираната структура, то ще се получи грешка.

*Пример:* 
```cpp
struct Person
{
    Person parent; // Ще даде грешка за недовършен тип, т.е. с неясен размер
    char* name;
};

```

Ако сложим на това поле да е от тип указател към типа на същата структура, то вече размерът на типа ще може да бъде определен, а с това и да се завърши дефиницията, тъй като размерът на нефункционален указател е с размер размерът на една клетка от виртуалната паметта, който зависи от архитектурата на процесора, но за x86-64-битова машина, този размер е 48 бита.

*Пример:* 

```cpp
struct Person
{
    Person* parent;
    char* name;
};

```

Структурите задават виртуални типове данни, т.е. типове несъществуващи за централния процесор, но такива дефинирани от програмиста, след като са били дефинирани, те могат да се използват като обикновените типове.

*Пример:* 

```cpp
2Dpoint point;
```

Полетата в структурата могат да се инициализират по два начина, един път още с декларацията чрес къдрави скоби или след това с оператор „точка“.

*Пример:* 
```cpp
2DPoint point = { 0, 0 };
```
или

```cpp
2DPoint point;
point.x = 0;
point.y = 0;
```

## Четене от файл

'''ifstream <name> (<path_to_file>)'''


## Писане във файл

'''ofstream <name> (<path_to_file>)'''

## Задачи



