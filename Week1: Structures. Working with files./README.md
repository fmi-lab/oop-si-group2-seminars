# Седмица 1: Работа с файлове
*20.02.2017*

## План

* [Преговор](#Преговор)
    * [Работа с масиви от символи](#Работа-с-масиви-от-символи)
    * [Структури](#Структури)
* [Нов материал](#Нов-материал)
    * [Четене от файл](#Четене-от-файл)
    * [Писане във файл](#Писане-във-файл)
* [Задачи](#Задачи)

## Преговор
#### [^План](#План)

### Работа с масиви от символи
#### [^План](#План)

Инициализацията на масиви от символи изглежда така:
* `char buf[10] = "";`, което е еквивалентно на `char buf[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};`;
* `char buf[10] = " ";`, което е еквивалентно на `char buf[10] = {' ', 0, 0, 0, 0, 0, 0, 0, 0, 0};`;
* `char buf[10] = "b";`, което е еквивалентно на `char buf[10] = {'b', 0, 0, 0, 0, 0, 0, 0, 0, 0};`;
* `char buf[10] = "buffer"`, което е еквивалентно на `char buf[10] = {'b', 'u', 'f', 'f', 'e', 'r', 0, 0, 0, 0};`;

Но не може да се изменя стойност на масив от символи така: `buf = "newbuf";`.

Затова, за да може да копирате един масив от символи в друг, трябва да използвате библиотеката `<cstring>`. В тази библиотека има три функции, които ще ви свършат работа за това, а именно `strcpy(destination, source);`,  `strncpy(destination, source, size);` и `strncat(destination, source, size);`.

* `strcpy(destination, source)` напълно копира `source` масивът в `destination` включително и терминиращата нула (`\0`), която определя края на низа съдържащ се в масива от символи. Хубаво е да се избягва, тъй като ако `source` е с по-голяма дължина от `destination`, то се получава [buffer overflow ](https://en.wikipedia.org/wiki/Buffer_overflow), а оттам програмата ви може да има сериозни уязвимости ([A Look at the Buffer-Overflow Hack](http://www.linuxjournal.com/article/2902));
* `strncpy(destination, source, size)` е по-сигурният начин за копиране на масиви от символи, тук вече има допълнителен параметър, броят на символите, които искаме да копираме от `source` в `destination`. Отново трябва да се внимава обаче, защото в определени случаи може терминиращата нула (`\0`) за край на низа да не бъде копирана и тогава ще трябва ръчно да се добавя. Например, ако се копират само 2 символа от `source` пък той има 5, то ще трябва `destination[3] = '\0';`.
* `strncat(destination, source, size)` е най-добрият вариант, въпреки че неговата цел е да се конкатенират два низа, то може да се изхитрим и да сложим терминиращата нула (`\0`) на първа позиция в `destination`, т.е. `destination[0] = '\0';` и след това `strncat(destination, source, sizeof(destination) - 1);`. По този начин винаги си осигуряваме терминиращата нула без прекалено много да мислим, дали я има или няма.

Необходимо е да обръщаме внимание на терминиращата нула, тъй като без нея програмата ни има [неопределено държание](https://en.wikipedia.org/wiki/Undefined_behavior), т.е. може да изглежда, че работи, но в някакъв момент с натрупването на код може и да спре да се държи по начина, по който се очаква с доста скрит бъг. Реално функции за работа със масиви от символи винаги се ориентират по това къде е терминиращата нула. Всъщност, ако преместите терминиращата нула в низ в по-предна позиция,
то ако я изведете на екрана със `std::cout` ще видите низа до индекса, на който сте сложили новата терминираща нула.

*Пример:*
```cpp
char name[10] = "Ivan";
name[2] = '\0';
std::cout << name << std::endl; // Извежда само "Iv" на екрана въпреки, че целият низ е "Ivan"
```

Размерът на нединамично заделен масив от символи може да се намери чрез функцията sizeof(array), като тъй като символите заемат 1B, то резултатът от нея ще бъде броя на елементите (капацитета) на масива от символи (като това не означава дължината на низа съдържащ се в този масив.

За масиви от други типове (които отново не са заделени динамично) може да се използва sizeof(array) / sizeof(type), за консистенция може да се ползва и за масиви от символи, например:

```cpp
char name[10] = "Ivan";
std::cout << sizeof(name) / sizeof(char) << std::endl; // Ще се изпише 10 на екрана, тъй като sizeof(name) = 10 * sizeof(char), а sizeof(char) = 1

int numbers[10] = {}; // Инициализира всички елементи на масива с нули, т.е. става {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
std::cout << sizeof(numbers) / sizeof(int) << std::endl; // Ще се изпише 10 на екрана, тъй като sizeof(numbers) = 10 * sizeof(int), а sizeof(int) = 4
```

Размерът на динамично заделени масиви не може да се вземе, затова обикновено се предава и като параметър във функции, т.е. променливата използвана при създаването на масива се подава като параметър за размерността на този масив.

#### [^План](#План)

### Структури
#### [^План](#План)

Конвенцията за именуването на структурите е имената им да са изписани в CamelCase (т.е. започва се с главна буква и ако името е по-дълго от една дума, то всяка следваща дума се залепя за предходната като първата ѝ буква е главна).

Представете си структурите като контейнери, които съдържат по няколко полета. Пример за контейнер е „точка“, тя в зависимост от това дали е в двумерното или тримерното пространство има две или три полета -- нейните координати по x и y или x, y и z.

Структурите, ако се ползват е най-добре да се използват в най-простият им вид, т.е. като контейнер за няколко променливи, тъй като ако се започне разширяване с различни член-функции (методи) по-добре да се използва клас.

Член-данните на структурата са достъпни отвън по подразбиране (т.е. са public). Това означава, че след като се създаде някакъв обект от тази структура, то неговите полета могат да се достъпят директно с оператора „точка“.

*Пример:* 
```cpp
struct 2DPoint
{
    double x;
    double y;
};

2DPoint point = {0, 0}; 
```
То, в такъв случай `std::cout << "(" << point.x << ", " << point.y << ")" << std::endl;` ще изведе на екрана `(0, 0)`. Това противоречи с един от основните принципи на обектно-ориентираното програмиране, а именно енкапсуалцията на данни, т.е. скриването на вътрешната имплементация от потребителя. Разбира се, и при структурите бихме могли да сложим спецификаторът за достъп `private` за тези член-данни и да използваме член-функции за достъп и работа с тях, но тогава отново е по-добре да се
използват класове. Като цяло структурите са подходящи в частни случаи, когато биха могли да се използват при структури от данни и това би улеснило имплементацията. 

Защо тогава има и структури и класове в C++? Най-очевидното обяснение е, че тъй като C++ е наследник на C, то в C няма концепция за обектно-ориентирано програмиране, такова разбира се би могло да се симулира (["Object-oriented Programming in ANSI-C" -- Axel Schreiner](https://www.cs.rit.edu/~ats/books/ooc.pdf)), но тъй като самите структури нямат конструктури и деструктури, то е необходима допълнителна грижа. В C++ класовете предоставят по-разширени възможности в сравнение със структурите,
но те лежат на една основа. Принципно в C++ обичайно употребата на клас вместо структура е по-добрия избор.

Структури могат да имат за член-данни променливи от тип на друга структура.  

*Пример:* 
```cpp
struct Circle
{
    double radius;
    2DPoint center;
};

```

В случай обаче, че този тип всъщност е типа на текущо дефинираната структура, то ще се получи грешка.

*Пример:* 
```cpp
struct Person
{
    Person parent; // Ще даде грешка за недовършен тип, т.е. с неясен размер
    char* name;
};

```

Ако сложим на това поле да е от тип указател към типа на същата структура, то вече размерът на типа ще може да бъде определен, а с това и да се завърши дефиницията, тъй като размерът на нефункционален указател е с размер размерът на една клетка от виртуалната паметта, който зависи от архитектурата на процесора, но за x86-64-битова машина, този размер е 48 бита.

*Пример:* 

```cpp
struct Person
{
    Person* parent;
    char* name;
};

```

Структурите задават виртуални типове данни, т.е. типове несъществуващи за централния процесор, но такива дефинирани от програмиста, след като са били дефинирани, те могат да се използват като обикновените типове.

*Пример:* 

```cpp
2Dpoint point;
```

Полетата в структурата могат да се инициализират по два начина, един път още с декларацията чрес къдрави скоби или след това с оператор „точка“.

*Пример:* 
```cpp
2DPoint point = { 0, 0 };
```
или

```cpp
2DPoint point;
point.x = 0;
point.y = 0;
```

#### [^План](#План)

## Нов материал
#### [^План](#План)

## Четене от файл
#### [^План](#План)


`ifstream <name> (<path_to_file>)`

#### [^План](#План)

## Писане във файл 
#### [^План](#План)

`ofstream <name> (<path_to_file>)`

#### [^План](#План)

## Задачи
#### [^План](#План)
#### [^План](#План)

