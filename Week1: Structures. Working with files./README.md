# Седмица 1: Структури. Работа с файлове. 
*20.02.2017*

## План

* [Преговор](#Преговор)
    * [Работа с масиви от символи](#Работа-с-масиви-от-символи)
    * [Stack и Heap памет](#stack-и-heap-памет)
        * [Stack](#stack)
        * [Heap](#heap)
    * [Структури](#Структури)
* [Нов материал](#Нов-материал)
    * [Четене от файл](#Четене-от-файл)
    * [Писане във файл](#Писане-във-файл)
* [Задачи](#Задачи)

## Преговор

### Работа с масиви от символи

[**^ План**](#План)

Инициализацията на масиви от символи изглежда така:
* `char buf[10] = "";`, което е еквивалентно на `char buf[10] = {0, 0, 0, 0, 0,
  0, 0, 0, 0, 0};`;
* `char buf[10] = " ";`, което е еквивалентно на `char buf[10] = {' ', 0, 0, 0,
  0, 0, 0, 0, 0, 0};`;
* `char buf[10] = "b";`, което е еквивалентно на `char buf[10] = {'b', 0, 0, 0,
  0, 0, 0, 0, 0, 0};`;
* `char buf[10] = "buffer"`, което е еквивалентно на `char buf[10] = {'b', 'u',
  'f', 'f', 'e', 'r', 0, 0, 0, 0};`;

Но стойността на вече инициализиран масив от символи не може да бъде променяна
по този начин: `buf = "newbuf";`.

Затова, за да може да копирате един масив от символи в друг, трябва да
използвате библиотеката `<cstring>`.

В тази библиотека има три функции, които ще ви свършат работа за това:
* `strcpy(destination, source);`;
* `strncpy(destination, source, size);`;
* `strncat(destination, source, size);`.

* `strcpy(destination, source)` напълно копира `source` масива в `destination`
  включително и терминиращата нула (`\0`), която определя края на низа съдържащ
  се в масива от символи. Хубаво е да се избягва, тъй като ако `source` е с
  по-голяма дължина от `destination`, то се стига до [buffer overflow
  ](https://en.wikipedia.org/wiki/Buffer_overflow), а оттам програмата ви може
  да има сериозни уязвимости ([A Look at the Buffer-Overflow
  Hack](http://www.linuxjournal.com/article/2902), [Exploit Tutorial: Buffer
  Overflow](https://www.reddit.com/r/hacking/comments/1wy610/exploit_tutorial_buffer_overflow/));
* `strncpy(destination, source, size)` е по-сигурният начин за копиране на
  масиви от символи, тук вече има допълнителен параметър - броят на символите
  които искаме да копираме от `source` в `destination`.
  Отново трябва да се внимава обаче, защото в определени случаи може
  терминиращата нула (`\0`) за край на низа да не бъде копирана и тогава ще
  трябва ръчно да се добавя.  Например, ако се копират само 2 символа от
  `source` пък той има 5, то ще трябва ръчно да добавим `destination[3] =
  '\0';`.
* `strncat(destination, source, size)` е най-добрият вариант, въпреки че
  неговата цел е да конкатенират два низа. Може да се изхитрим и да сложим
  терминиращата нула (`\0`) на първа позиция в `destination`, т.е.
  `destination[0] = '\0';` и след това `strncat(destination, source,
  sizeof(destination) - 1);`. По този начин винаги си осигуряваме терминираща
  нула без прекалено много да мислим на коя позиция ще трябва да я поставяме.

Необходимо е да обръщаме внимание на терминиращата нула (`\0`), тъй като без нея
програмата ни има потенциално [неопределено
държание](https://en.wikipedia.org/wiki/Undefined_behavior), т.е. може да
изглежда, че работи, но в някакъв момент с натрупването на код може и да спре да
се държи по начина, по който се очаква при това с доста скрит бъг. 

Реално функции за работа със масиви от символи винаги се ориентират по това къде
е терминиращата нула. Всъщност, ако сложите терминираща нула в низ на предна
позиция, то ако изведете масива на екрана със `std::cout` ще видите низа до
индекса, на който сте сложили новата терминираща нула.

*Пример:*

```cpp
char name[10] = "Dirk"; 
name[1] = '\0';
std::cout << name << std::endl; // Извежда само "D" на екрана въпреки, че целият низ е "D\0rk"
```

Размерът на нединамично заделен масив от символи може да се намери чрез
функцията sizeof(array), тъй като символите заемат 1 байт, то резултатът от нея
ще бъде броя на елементите (капацитета) на масива от символи (като това не
означава дължината на низа съдържащ се в този масив.

За да определим дължината на текстът съдържащ се в масива, то трябва целия масив
да бъде сканиран символ по символ до срещане на символа за край на низ `'\0'`.

За масиви от други типове (които отново не са заделени динамично) може да се
използва sizeof(array) / sizeof(type), за консистенция може да се ползва и за
масиви от символи, например:

```cpp
char name[10] = "Todd";
std::cout << sizeof(name) / sizeof(char) << std::endl; // Ще се изпише 10 на екрана, тъй като 
                                                       // sizeof(name) = 10 * sizeof(char),
                                                       // а sizeof(char) = 1
int numbers[10] = {}; // Инициализира всички елементи на масива с нули,
                      // т.е. става {0, 0, 0, 0, 0, 0, 0, 0, 0, 0} 
std::cout << sizeof(numbers) / sizeof(int) << std::endl; // Ще се изпише 10 на екрана, тъй като
                                                         // sizeof(numbers) = 10 * sizeof(int),
                                                         // а sizeof(int) = 4 
```

Размерът на динамично заделени масиви не може да се вземе, т.е. sizeof() връща
размера на указателя, и тъй като той не е указател към функция, то размерът му
зависи от архитектурата на процесора, но за x86-64-битова машина указателят е с
размер равен на:
* размерът на адрес от виртуалната памет - 48 бита;         
* дължината на една машинна дума - 64 бита .

Дали ще се използва виртуална памет зависи от операционната система, но със
сигурност размерът е определен.

В крайна сметка всеки масив е указател към първия си елемент.

*Пример:*

```cpp
char name[10] = "Farah";

int newNameSize = sizeof(name);
char* newName = new char[newNameSize];

if (newNameSize > 0)
{
    newName[0] = '\0';
    strncat(newName, "Lydia", newNameSize - 1);
}

std::cout << *name << std::endl; // Ще изведе "F" на екрана
std::cout << *newName << std::endl; // Ще изведе "L" на екрана

delete[] newName; // Грижим се да освободим паметта от динамично заделените променливи след 
                  // като вече не са ни необходими
```

Също така може да се забавлявате с указателна аритметика, в най-простият си вид
представлява следното:

*Пример:*
```cpp
char name[10] = "Patrick";
for (int i = 0; i < 10; i++)
{
    std::cout << *(name + i); // *(name + i) е еквивалентно на name[i]
}
std::cout << std::endl; // Ще се изпечата "Patrick" на екрана
```

Винаги при предаване и на обикновен масив, както и на динамично заделен масив
като параметър на функция, те се предават единствено като указател, и затова
рябва да се предава и дължината на масива като допълнителен аргумент. 

Както се казва: **"The first step to learning C is understanding that pointers and
arrays are the same thing. The second step is understanding that pointers and
arrays are different."**

Ще ви боли малко главата от това твърдение, но само с решаване на (много) задачи
ще може да го усетите.

Също така когато предавате масив от символи като аргумент на дадена функция, то
тя е хубаво да приема `const char*`, тъй като това ви позволява да подавате
масива от символи просто в кавички, т.е. някакъв временен обект, а не да го
присвоявате на променлива и чак след това да я подавате на функцията.

Разбира се, може да се намери заобиколен път, един от които е да създадем
wrapping структура и всъщност чрез нея да подмятаме масиви по функциите.

*Пример:*
```cpp
template <typename T>
struct ArrayWrapper
{
    T array[10];
}

template <typename T>
int getSizeOfArray(const ArrayWrapper<T>& myArray) const
{
    return sizeof((*myArray).array) / sizeof(*myArray).array[0]);
}

int main()
{
    ArrayWrapper<int> myArrayWrapper;
    std::cout << getSizeOfArray(myArrayWrapper) << std::endl; // Ще изведе на екрана 10
    return 0;
}
```
Но това отново няма да сработи за динамични масиви, така че най-добре е да
използвате допълнителен параметър за размер при дефинициите на функциите, които
приемат масиви като аргументи и ги обработват по някакъв начин.

### Stack и Heap памет

Защо да не можем да определим размера и на динамично заделения масив?

#### Stack
[**^ План**](#План)

**Особености:**
* Специален регион от паметта на компютъра, в който се пазят временно
  променливите създадени във всяка функция, включително и в main(). 
* LIFO (last in, fist out) структура от данни, която се управлява и оптимизира
  от централния процесор. 
* Всеки път, в който функция декларира нова променлива, тя бива добавяна във
  stack-а.

**Предимства:** 
* Паметта се управлява вътрешно и вие не трябва да полагате допълнителни усилия
  за това, т.е. не трябва да заделяте памет ръчно, а след това съответно да я
  освобождавате ръчно.
* Централният процесор организира stack-овата памет, при което продуктивността е
  възможно най-висока и следователно достъпът до тези променливи е бърз и
  ефективен, в допълнение паметта няма да бъде фрагментирана.

**Недостатъци:**
* Има ограничение, зависещо от операционната система, за размер на променливите,
  които се пазят в stack-a (stack-овата рамка). Ако надхвърлите капацитета на
  stack-а ще получите [stack
  overflow](https://en.wikipedia.org/wiki/Stack_buffer_overflow) (откъдето идва
  и името на сайта, от който си копирате повече от половината от решенията на
  домашните).
* Променливите не могат да бъдат преоразмерявани (например след като сте създали
  масив от 10 символа, той не може да бъде преоразмерен на 20. На по-малко от 10
  символа би могъл да бъде преоразмерен, но само фиктивно, т.е. просто да не
  използвате остналите 5 места за символ и да сложите символ за край на низ на
  6-та позиция, което не е много добър подход).

#### Heap
[**^ План**](#План)

**Предимства:**
* Обхваща повече памет от stack-а.
* За разлика от stack-а, heap-а няма ограничение за размера на променливите,
  които може да държи (освен, разбира се, физическите ограничения и размер на
  вашия компютър, т.е. големинат на вашата RAM)
* Променливите могат да бъдат преоразмерени (например масив от 10 елемента може
  да стане на масив от 20).

**Недостатъци:**
* Трябва управлението на памет да се осъществява ръчно, т.е. при заделяне се
  използва ключовата дума `new`, при изпълнението на която се връща указател, и
  `delete`, която служи за освобождаване на паметта. По правило за всяко `new`
  трябва да има `delete`, в противен случай най-вероятно ще имате *memory leak*
  някъде из програмата си (т.е. ще имате заделена памет, която е неизползваема
  след като е спряла да ви трябва).
* Малко по-бавно е прочитането в и четенето от променливи, тъй като това става
  чрез използването на указатели.
* Може да фрагментира паметта.

![Dirk Gently](http://static.tumblr.com/ac110f12ac7a128d02fd902143fc3ce8/uh1lahx/XuZog43qd/tumblr_static_c9fgm2dpp1s84kgg4cs0wkk44.gif)
--

**Извод:**
* Статичните променливи се пазят в stack-а и паметта, която заемат се установява
  по време на компилация (compile time). Също така те заемат последователни
  блокове от паметта. 
* Динамичните променливи се пазят в heap-а и паметта, която заемат се установява
  по време на изпълнение (runtime) и необходимата за деларирането им памет се
  заделя от места от където това е възможно. 

### Структури
[**^ План**](#План)

Конвенцията за именуването на структурите е имената им да са изписани в
CamelCase (т.е. започва се с главна буква и ако името е по-дълго от една дума,
то всяка следваща дума се залепя за предходната като първата ѝ буква е главна).

Представете си структурите като контейнери, които съдържат по няколко полета.
Пример за контейнер е „точка“, тя в зависимост от това дали е в двумерното или
тримерното пространство има две или три полета - нейните координати по x и y
или x, y и z.

Структурите, ако се ползват е най-добре да се използват в най-простият им вид,
т.е. като контейнер за няколко променливи, тъй като ако се започне разширяване с
различни член-функции (методи) по-добре да се използва клас.

Член-данните на структурата са достъпни отвън по подразбиране (т.е. са public).
Това означава, че след като се създаде някакъв обект от тази структура, то
неговите полета могат да се достъпят директно с оператора „точка“.

*Пример:* 

```cpp
struct 2DPoint { 
    double x;
    double y;
 };

2DPoint point = {0, 0};
```

То, в такъв случай `std::cout << "(" << point.x << ", " << point.y << ")" <<
std::endl;` ще изведе на екрана `(0, 0)`. Това противоречи с един от основните
принципи на обектно-ориентираното програмиране, а именно енкапсуалцията на
данни, т.е. скриването на вътрешната имплементация от потребителя. Разбира се, и
при структурите бихме могли да сложим спецификаторът за достъп `private` за тези
член-данни и да използваме член-функции за достъп и работа с тях, но тогава
отново е по-добре да се използват класове. Като цяло структурите са подходящи в
частни случаи, когато биха могли да се използват при структури от данни и това
би улеснило имплементацията. 

Защо тогава има и структури и класове в C++? Най-очевидното обяснение е, че тъй
като C++ е наследник на C, то в C няма концепция за обектно-ориентирано
програмиране, такова разбира се би могло да се симулира (["Object-oriented
Programming in ANSI-C" - Axel
Schreiner](https://www.cs.rit.edu/~ats/books/ooc.pdf)), но тъй като самите
структури нямат конструктури и деструктури, то е необходима допълнителна грижа.
В C++ класовете предоставят по-разширени възможности в сравнение със
структурите, но те лежат на една основа. Принципно в C++ обичайно употребата на
клас вместо структура е по-добрия избор.

Структури могат да имат за член-данни променливи от тип на друга структура.  

*Пример:* 

```cpp 
struct Circle { 
    double radius; 
    2DPoint center;
};
```

В случай обаче, че този тип всъщност е типа на текущо дефинираната структура, то
ще се получи грешка.

*Пример:*

```cpp
struct Person {
    Person parent; // Ще даде грешка за недовършен тип, т.е. с неясен размер
    char* name;
};
```

Ако сложим на това поле да е от тип указател към типа на същата структура, то
вече размерът на типа ще може да бъде определен, а с това и да се завърши
дефиницията. 

*Пример:* 

```cpp
struct Person {
    Person* parent;
    char* name;
};
```

Структурите задават виртуални типове данни, т.е. типове несъществуващи за
централния процесор, но такива дефинирани от програмиста, след като са били
дефинирани, те могат да се използват като обикновените типове.

*Пример:* 

```cpp
2Dpoint point;
```

Полетата в структурата могат да се инициализират по два начина, един път още с
декларацията чрес къдрави скоби или след това с оператор „точка“.

*Пример:*

```cpp
2DPoint point = {0, 0};
```
или
```cpp
2DPoint point;
point.x = 0;
point.y = 0;
```

## Нов материал
[**^ План**](#План)

За да може да четем и записваме във файлове ще трябва да добавим библиотеката
`<fstream>` заглавната част на програмата.

Функциите, които ще използваме от тази библиотека са:
* `ifstream name_of_stream(path_to_file)` - за четене от файл;
* `ofstream name_of_stream(path_to_file)` - за писане във файл;
* `fstream name_of_stream(path_to_file)` - за четене от и писане във файл.

След приключване на операциите върху даден файл, то той трябва да бъде затворен
със `name_of_stream.close()`. Потоците `std::cin` и `std::cout` не могат да
бъдат затворени.

### Четене от файл
[**^ План**](#План)

За четене на низове от конзолата се избягва употребата на оператора `>>`, тъй
като при него често се стига до [buffer
overflow](https://en.wikipedia.org/wiki/Buffer_overflow). 

Вместо него се използват:
* `name_of_stream.getline(destination, sizeof(destination), delimiter);`; като
  *delimiter* е незадължителен параметър.

Идентична е употребата както за входния потребителски поток `cin`, така и за
файловите потоци.

Следователно, ако низ се чете от конзолата по този начин: 

*Пример:*

```cpp
char name[20] = "";
while(std::cin.getline(name, sizeof(name))) // със cin.getline() автоматично се добавя
                                            // символа за край на ред '\0', така че не 
                                            // е нужно да се притесняваме за това
{
    std::cout << name << std::endl;
}
```

То ред от файл би се прочел така: 

*Пример:*

```cpp
std::ifstream myFile("myFile.txt");

char name[10];
while(myFile.getline(name, sizeof(name))) // чете се ред, докато може (т.е.
                                          // докато не е достигнат края на файла
{
    std::cout << name << std::endl;
}

myFile.close();
```
Има две функции за потоково четене които изглеждат почти идентично:
* `getline(name_of_stream, string)`;
* `name_of_stream.getline(char array, sizeof(array))`.

Както се вижда едната функция ползва string (те отново вътрешно ползват масиви от символи, но цялата грижа,
която се поема при създаване и управление на този масив се поема от
имплементацията), а другата си използва масив от символи.

Тъй като е важно да бъдат овладяни операциите с масиви и грижата за паметта, в
този курс ще се работи най-вече с масиви от символи или така наречените "C
strings", тъй като те са наследени от C.

Понякога, когато знаем, че има натискане на клавиша Enter преди четене на низ от
конзола или друг поток е хубаво да се зачисти буфера от `\n` (символа за нов
ред) с `cin.ignore()`.

*Пример:*

```cpp
std::ifstream myFile("myFile.txt");

int number = 0; // ако знаем, че има написано на първи ред от файла някакво число (например брой на
                // имена, които ни интересуват)
myFile >> number; // четем числото, но освен него има символ за край на ред, и сме стигнали точно 
                  // преди него с прочитането на горното число 
myFile.ignore(); // за да прескочим този символ, използваме name_of_stream.ignore()
                 // в противен случай ще имаме допълнително име при четене (име състочщо се от
                 // символа '\n', което ще се вижда като празно място на екрана
char name[10];
int i = 0;
while(i < number && myFile.getline(name, sizeof(name)))
{
    std::cout << name << std::endl;
}

```

### Писане във файл
[**^ План**](#План)

```cpp
std::ofstream myFile("myFile.txt");

myFile << "Amanda" << std::endl;
```

За навигация във файлове и работа с двоични файлове -> [Седмица 2: Двоични
файлове. Навигация във файлове. Класове.](../Week 2: Binary Files. Navigation in
Files. Classes.)

## Задачи

[**^ План**](#План)

1. Направете структура *Date* с три полета от тип int: year, month, day.
1. Направете структура *Actor*, която да има полета *firstName* и *lastName* с
   по 16 символа, поле от тип Date за рожден ден и поле от тип int за брой
   филми, в които актьорът е играл.
1. Отворете файлът [actors.txt](actors.txt) за четене.
1. На първи ред от файла има число, прочетете го и създайте динамично масив от
   актьори с размерност даденото число.
1. Четете ред по ред и създавайте нов актьор с данните дадени на всеки ред.

   Ползвайте незадължителния трети параметър на
   `name_of_stream.getline(destination, sizeof(destination), delimiter)`, в един
   от случаите той е ' ', иначе - '|', може да потрябва да се използва
   `name_of_stream.ignore()`).
1. Направете функция, която да преработва (парсва) прочетената като масив от
   символи дата в обект от тип Date и я запазва в съответното поле на текущият
   актьор.
1. Може да направите функция, която пресмята колко годишен е дадения актьор.
1. Може да си отворите файл за писане (ако не съществува той ще бъде автоматично
   създаден от програмата) и да запишете актьорите и тяхната възраст, също така
   по колко филма средно на година са правили през живота си.
   
