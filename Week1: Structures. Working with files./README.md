# Седмица 1: Работа с файлове
*20.02.2017*

## План

* [Преговор](#Преговор)
    * [Работа с масиви от символи](#Работа-с-масиви-от-символи)
    * [Stack и Heap памет](#stack-и-heap-памет)
        * [Stack](#stack)
        * [Heap](#heap)
    * [Структури](#Структури)
* [Нов материал](#Нов-материал)
    * [Четене от файл](#Четене-от-файл)
    * [Писане във файл](#Писане-във-файл)
* [Задачи](#Задачи)

## Преговор

### Работа с масиви от символи

[**^ План**](#План)

Инициализацията на масиви от символи изглежда така:
* `char buf[10] = "";`, което е еквивалентно на `char buf[10] = {0, 0, 0, 0, 0,
  0, 0, 0, 0, 0};`;
* `char buf[10] = " ";`, което е еквивалентно на `char buf[10] = {' ', 0, 0, 0,
  0, 0, 0, 0, 0, 0};`;
* `char buf[10] = "b";`, което е еквивалентно на `char buf[10] = {'b', 0, 0, 0,
  0, 0, 0, 0, 0, 0};`;
* `char buf[10] = "buffer"`, което е еквивалентно на `char buf[10] = {'b', 'u',
  'f', 'f', 'e', 'r', 0, 0, 0, 0};`;

Но не може да се изменя стойност на масив от символи след като е бил
инициализира по начина показан по-горе, т.е.: `buf = "newbuf";`.

Затова, за да може да копирате един масив от символи в друг, трябва да
използвате библиотеката `<cstring>`. В тази библиотека има три функции, които ще
ви свършат работа за това, а именно `strcpy(destination, source);`,
`strncpy(destination, source, size);` и `strncat(destination, source, size);`.

* `strcpy(destination, source)` напълно копира `source` масивът в `destination`
  включително и терминиращата нула (`\0`), която определя края на низа съдържащ
  се в масива от символи. Хубаво е да се избягва, тъй като ако `source` е с
  по-голяма дължина от `destination`, то се получава [buffer overflow
  ](https://en.wikipedia.org/wiki/Buffer_overflow), а оттам програмата ви може
  да има сериозни уязвимости ([A Look at the Buffer-Overflow
  Hack](http://www.linuxjournal.com/article/2902));
* `strncpy(destination, source, size)` е по-сигурният начин за копиране на
  масиви от символи, тук вече има допълнителен параметър, броят на символите,
  които искаме да копираме от `source` в `destination`. Отново трябва да се
  внимава обаче, защото в определени случаи може терминиращата нула (`\0`) за
  край на низа да не бъде копирана и тогава ще трябва ръчно да се добавя.
  Например, ако се копират само 2 символа от `source` пък той има 5, то ще
  трябва `destination[3] = '\0';`.
* `strncat(destination, source, size)` е най-добрият вариант, въпреки че
  неговата цел е да се конкатенират два низа, то може да се изхитрим и да сложим
  терминиращата нула (`\0`) на първа позиция в `destination`, т.е.
  `destination[0] = '\0';` и след това `strncat(destination, source,
  sizeof(destination) - 1);`. По този начин винаги си осигуряваме терминиращата
  нула без прекалено много да мислим, дали я има или няма.

Необходимо е да обръщаме внимание на терминиращата нула, тъй като без нея
програмата ни има [неопределено
държание](https://en.wikipedia.org/wiki/Undefined_behavior), т.е. може да
изглежда, че работи, но в някакъв момент с натрупването на код може и да спре да
се държи по начина, по който се очаква с доста скрит бъг. Реално функции за
работа със масиви от символи винаги се ориентират по това къде е терминиращата
нула. Всъщност, ако преместите терминиращата нула в низ в по-предна позиция, то
ако я изведете на екрана със `std::cout` ще видите низа до индекса, на който сте
сложили новата терминираща нула.

*Пример:*

```cpp
char name[10] = "Dirk"; 
name[2] = '\0';
std::cout << name << std::endl; // Извежда само "Di" на екрана въпреки, че целият низ е "Dirk"
```

Размерът на нединамично заделен масив от символи може да се намери чрез
функцията sizeof(array), като тъй като символите заемат 1B, то резултатът от нея
ще бъде броя на елементите (капацитета) на масива от символи (като това не
означава дължината на низа съдържащ се в този масив.

За да определим дължината на текста съдържащ се в масива, то треябва целия масив
да бъде сканиран символ по символ до срещане на символа за край на низ `'\0'`.

За масиви от други типове (които отново не са заделени динамично) може да се
използва sizeof(array) / sizeof(type), за консистенция може да се ползва и за
масиви от символи, например:

```cpp
char name[10] = "Todd";
std::cout << sizeof(name) / sizeof(char) << std::endl; // Ще се изпише 10 на екрана, тъй като 
                                                       // sizeof(name) = 10 * sizeof(char), а sizeof(char) = 1
int numbers[10] = {}; // Инициализира всички елементи на масива с нули, т.е. става {0, 0, 0, 0, 0, 0, 0, 0, 0, 0} 
std::cout << sizeof(numbers) / sizeof(int) << std::endl; // Ще се изпише 10 на екрана, тъй като
                                                         // sizeof(numbers) = 10 * sizeof(int), а sizeof(int) = 4 
```

Размерът на динамично заделени масиви не може да се вземе, затова обикновено се
предава и като параметър във функции, т.е. променливата използвана при
създаването на масива се подава като параметър за размерността на този масив.

В крайна сметка всеки масив е указател към първия си елемент.

*Пример:*

```cpp
char name[10] = "Farah";

int newNameSize = sizeof(name);
char* newName = new char[newNameSize];

if (newNameSize > 0)
{
    newName[0] = '\0';
    strncat(newName, "Lydia", newNameSize - 1);
}

std::cout << *name << std::endl; // Ще изведе "F" на екрана
std::cout << *newName << std::endl; // Ще изведе "L" на екрана
```

Тогава защо да не можем да определим размера и на динамично заделения масив?

### Stack и Heap памет

#### Stack
[**^ План**](#План)

**Особености:**
* Специален регион от паметта на компютъра, в който се пазят временно
  променливите създадени във всяка функция, включително и в main(). 
* LIFO (last in, fist out) структура от данни, която се управлява и оптимизира
  от централния процесор. 
* Всеки път, в който функция декларира нова променлива, тя бива добавяна във
  stack-а.
* Променливите са локални за дадена функция, т.е. биват изваждани от stack-а, а
  паметта, която са заемали се освобождава.

**Предимства:** 
* Паметта се управлява вътрешно и вие не трябва да полагате допълнителни усилия
  за това, т.е. не трябва да заделяте памет ръчно, а след това съответно да я
  освобождавате ръчно.
* Централният процесор организира stack-овата памет, при което продуктивността е
  възможно най-висока и следователно достъпът до тези променливи е бърз и
  ефективен, в допълнение паметта няма да бъде фрагментирана.

**Недостатъци:**
* Има ограничение, зависещо от операционната система, за размер на променливите,
  които се пазят в stack-a (например не може да пазите масив от символи по-голям
  от 256 байта). Ако надхвърлите капацитета на stack-а ще получите [stack
  overflow](https://en.wikipedia.org/wiki/Stack_buffer_overflow) (откъдето идва и името
  на сайта, от който си копирате повече от половината от решенията на
  домашните).
* Променливите не могат да бъдат преоразмерявани (например след като сте създали
  масив от 10 символа, той не може да бъде преоразмерен на 20. На по-малко от 10
  символа би могъл да бъде преоразмерен, но само фиктивно, т.е. просто да не
  използвате остналите 5 места за символ и да сложите символ за край на низ на
  6-та позиция, което не е много добър подход).

#### Heap
[**^ План**](#План)

**Предимства:**
* Обхваща повече памет от stack-а.
* За разлика от stack-а, heap-а няма ограничение за размера на променливите,
  които може да държи (освен, разбира се, физическите ограничения и размер на
  вашия компютър, т.е. големинат на вашата RAM)
* Променливите могат да бъдат преоразмерени (например масив от 10 елемента може
  да стане на масив от 20).

**Недостатъци:**
* Трябва управлението на памет да се осъществява ръчно, т.е. при заделяне се
  използва ключовата дума `new`, при изпълнението на която се връща указател, и
  `delete`, която служи за освобождаване на паметта. По правило за всяко `new`
  трябва да има `delete`, в противен случай най-вероятно ще имате *memory leak*
  някъде из програмата си (т.е. ще имате заделена памет, която е неизползваема
  след като е спряла да ви трябва).
* Малко по-бавно е прочитането в и четенето от променливи, тъй като това става
  чрез използването на указатели.
* Може да фрагментира паметта.

--

**Извод:**
* Статичните променливи се пазят в stack-а и паметта, която заемат се установява
  по време на компилация (compile time). Също така те заемат последователни
  блокове от паметта. 
* Динамичните променливи се пазят в heap-а и паметта, която заемат се установява
  по време на изпълнение (runtime) и необходимата за деларирането им памет се
  заделя от места от където това е възможно. Затова размерът им не може да бъде
  установен със `sizeof()`.

### Структури
[**^ План**](#План)

Конвенцията за именуването на структурите е имената им да са изписани в
CamelCase (т.е. започва се с главна буква и ако името е по-дълго от една дума,
то всяка следваща дума се залепя за предходната като първата ѝ буква е главна).

Представете си структурите като контейнери, които съдържат по няколко полета.
Пример за контейнер е „точка“, тя в зависимост от това дали е в двумерното или
тримерното пространство има две или три полета - нейните координати по x и y
или x, y и z.

Структурите, ако се ползват е най-добре да се използват в най-простият им вид,
т.е. като контейнер за няколко променливи, тъй като ако се започне разширяване с
различни член-функции (методи) по-добре да се използва клас.

Член-данните на структурата са достъпни отвън по подразбиране (т.е. са public).
Това означава, че след като се създаде някакъв обект от тази структура, то
неговите полета могат да се достъпят директно с оператора „точка“.

*Пример:* 

```cpp
struct 2DPoint { 
    double x;
    double y;
 };

2DPoint point = {0, 0};
```

То, в такъв случай `std::cout << "(" << point.x << ", " << point.y << ")" <<
std::endl;` ще изведе на екрана `(0, 0)`. Това противоречи с един от основните
принципи на обектно-ориентираното програмиране, а именно енкапсуалцията на
данни, т.е. скриването на вътрешната имплементация от потребителя. Разбира се, и
при структурите бихме могли да сложим спецификаторът за достъп `private` за тези
член-данни и да използваме член-функции за достъп и работа с тях, но тогава
отново е по-добре да се използват класове. Като цяло структурите са подходящи в
частни случаи, когато биха могли да се използват при структури от данни и това
би улеснило имплементацията. 

Защо тогава има и структури и класове в C++? Най-очевидното обяснение е, че тъй
като C++ е наследник на C, то в C няма концепция за обектно-ориентирано
програмиране, такова разбира се би могло да се симулира (["Object-oriented
Programming in ANSI-C" - Axel
Schreiner](https://www.cs.rit.edu/~ats/books/ooc.pdf)), но тъй като самите
структури нямат конструктури и деструктури, то е необходима допълнителна грижа.
В C++ класовете предоставят по-разширени възможности в сравнение със
структурите, но те лежат на една основа. Принципно в C++ обичайно употребата на
клас вместо структура е по-добрия избор.

Структури могат да имат за член-данни променливи от тип на друга структура.  

*Пример:* 

```cpp 
struct Circle { 
    double radius; 
    2DPoint center;
};
```

В случай обаче, че този тип всъщност е типа на текущо дефинираната структура, то
ще се получи грешка.

*Пример:*

```cpp
struct Person {
    Person parent; // Ще даде грешка за недовършен тип, т.е. с неясен размер
    char* name;
};
```

Ако сложим на това поле да е от тип указател към типа на същата структура, то
вече размерът на типа ще може да бъде определен, а с това и да се завърши
дефиницията. Тъй като размерът на нефункционален указател зависи от
архитектурата на процесора, но за x86-64-битова машина той е с размер равен на:
* размерът на адрес от виртуалната памет - 48 бита;
* дължината на една машинна дума - 64 бита .

Дали ще се използва виртуална памет зависи от операционната система, но със
сигурност размерът е определен.

*Пример:* 

```cpp
struct Person {
    Person* parent;
    char* name;
};
```

Структурите задават виртуални типове данни, т.е. типове несъществуващи за
централния процесор, но такива дефинирани от програмиста, след като са били
дефинирани, те могат да се използват като обикновените типове.

*Пример:* 

```cpp
2Dpoint point;
```

Полетата в структурата могат да се инициализират по два начина, един път още с
декларацията чрес къдрави скоби или след това с оператор „точка“.

*Пример:*

```cpp
2DPoint point = {0, 0};
```
или
```cpp
2DPoint point;
point.x = 0;
point.y = 0;
```

## Нов материал
[**^ План**](#План)

За да може да четем и записваме във файлове ще трябва да добавим библиотеката
`<fstream>` заглавната част на програмата.

Функциите, които ще използваме от тази библиотека за четене на обикновени
файлове ще са `ifstream name (path_to_file)`, а за писане във файлове
съответно `ofstream name (path_to_file)`.

Както при четенето на низове от конзола е правилно да се използва
`cin.getline(destination, sizeof(destination));`, тъй като при елементарно
използване на оператора `>>` шансът за buffer overflow е почти сигурен.
Има две функции за потоково четене `getline(stream, string)` и
`stream.getline(char array, sizeof(array))`. Както се вижда едната функция
ползва string (те отново вътрешно ползват масиви от символи, но цялата грижа,
която се поема при създаване и управление на този масив се поема от
имплементацията), а другата си използва 
Като преди да се използва е хубаво да се зачисти буфера от `\n` (символа за нов
ред) с `cin.ignore()`.

*Пример:*

```cpp
char name[20] = "";
std::cin.ignore();
std::cin.getline(name, sizeof(name)); // със cin.getline() автоматично се добавя
                                      // символа за край на ред '\0', така че не 
                                      // е нужно да се притесняваме за това
std::cout << name << std::endl;
```

При отварянето на файл, отново имаме поточно предаване, и следователно файлът
може да бъде използван по сходен начин на начинът по който използваме `cin` и
`cout`.

### Четене от файл

[**^ План**](#План)

### Писане във файл

`ofstream <name> (<path_to_file>)`

[**^ План**](#План)

## Задачи

[**^ План**](#План)

