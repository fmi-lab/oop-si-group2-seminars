# Седмица 5: Класове с динамични член-данни. Канонично представяне. 
*20.03.2017*

## План

* [Класове с динамични член-данни](#Класове-с-динамични-член-данни)
* [Канонично представяне](#Канонично-представяне)
  * [Конструктор](#Конструктор)
    * [Инициализиращ списък](#Инициализиращ-списък)
    * [Конструктор по подразбиране](#Конструктор-по-подразбиране)
    * [Конструктор с параметри](#Конструктор-с-параметри)
      * [Стойности по подразбиране](#Стойности-по-подразбиране)
    * [Копиращ конструктор](Копиращ-конструктор)
  * [Оператор за присвояване](#Оператор-за-присвояване)
  * [Деструктор](#Деструктор)
* [Задачи](#Задачи)

## Класове с динамични член-данни
[**^ План**](#План)

Класовете с динамични член-данни (т.е. използват оператора new) изискват повече
грижа, поради което минимумът на функциите които трябва да имплементирате за
такъв клас е: конструктор, копиращ конструктор, оператор за присвояване и
деструктор или иначе казано да направите [канонично
представяне](#Класове-с-динамични-член-данни) на дефинираният от вас клас.

В някои специални случаи може да не искаме потребителят да може да копира или
присвоява на един обект друг, тогава щр трябва да декларираме дадената
член-функция без да я дефинираме и да я направим private. По този начин не се
генерира от компилатора метод по подразбиране и си спестяваме куп главоболия
описани по-долу.

## Канонично представяне
[**^ План**](#План)

### Конструктор
[**^ План**](#План)

Конструкторът е член-функция, чието име е същотото като името на класа и няма
тип на връщане. 

#### Инициализиращ списък
[**^ План**](#План)

#### Конструктор по подразбиране 
[**^ План**](#План)

#### Конструктор с параметри
[**^ План**](#План)

##### Стойности по подразбиране
[**^ План**](#План)

Подаването на стойности по подразбиране е валидно, както за обикновени функции,
така и за конструктори. Отново особеността е, че веднъж зададете ли стойност по
подразбиране на някой от параметрите на функцията, то всички останали параметри
намиращи се вдясно от параметъра по подразбиране трябва също да са параметри по
подразбиране.

#### Копиращ конструктор
[**^ План**](#План)

Ако не дефинираме собствен оператор за присвояване, то ще се генерира и извика
оператора за присвояване по подразбиране, а той присвоява последователно
членовете на един обект от този клас на друг обект от същия клас, като за
указателите се извършва побитово копиране. Резултатът от подобно действие, че и
указателите и на двата обекта сочат към едно и също място.

Също така имаме два обекта, чиито член-данни указатели сочат на едно и също
място, следователно ако един от тях бъде унищожен по някаква причина (например
излизане от областта на видимост (scope)), то неговият деструктор ще изтрие
паметта сочена и от указателя на другия обект.

Освен всичко при копиращия конструктор по подразбиране възниква проблем при
предаване на обекти по стойност, тъй като при подаване на даден обект като
аргумент на функция, то копиращия конструктор се извиква, и се получава горния
проблем за два обекта сочещи към едни и същи данни, но в последствие след
приключването на функцията деструкторът на локалния обект се извиква и в
резултат указателите на обекта предаден като аргумент спират да сочат към
съществуващи данни, т.е. стават невалидни. Тъй като използването на оператора
delete върху указател, който вече е бил изтрит предизвиква неопределено
държание, което поражда още един проблем при излизането на обекта подаден като
аргумент от областта на видимост.

Затова си пишем своя версия на копиращия конструктор.

### Оператор за присвояване
[**^ План**](#План)

При недефиниран оператор за присвояване, аналогично на копиращия конструктор, ще
се генерира оператор за присвояване по подразбиране със същотото поведение.

В допълнение на проблема създаден при копиращия конструктор по подразбиране, за
изтриването на член-данна на обект, чийто указател сочи към място към което сочи
и указател на друг обект. Оператора за присвояване по подразбиране оставя памет,
която никога няма да бъде изтрита, тъй като указателят сочел към нея вече сочи
другаде ([memory leak](https://en.wikipedia.org/wiki/Memory_leak)).

Затова си пишем своя версия на оператора за присвояване.

### Деструктор
[**^ План**](#План)

Докато при класовете несъдржащи динамични данни можехме да минем и само с един
конструктор, то тук ще трябва да освободим и паметта, която сме заделили при
инициализацията на даден обект.

Обикновено просто правило е, че в зависимост от типа на оператора new, който сме
използвали, т.е. или само new, или new[], то трябва да използваме съответния
оператор delete, т.е. или само delete, или delete[].

## Задачи
[**^ План**](#План)
1. Да се реализира [задачата за стека](https://github.com/fmi-lab/oop-si-group2-seminars/tree/master/Week04:%20Classes.%20Overloading%20operators./README.md/#Задачи) с динамичен масив (т.е. трябва да се използва каноничното представяне на класа).

