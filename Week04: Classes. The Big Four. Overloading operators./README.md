# Седмица 4: Класове. Голямата четворка. Предефиниране на оператори.
*13.03.2017*

## План

* [Принципи на обектно ориентираното програмиране]()
  * [Енкапсулация](#Енкапсулация)
    * [Селектори](#Селектори)
    * [Мутатори](#Мутатори)
  * [Абстракция с данни](#Абстракция-с-данни)
  * [Наследяване](#Наследяване)
  * [Полиморфизъм](#Полиморфизъм)
* [Класове](#Класове)
  * [Разлики между класове и структури](#Разлики-между-класове-и-структури)
  * [Организация на файловете](#Организация-на-файловете)
    * [Заглавни файлове](#Заглавни-файлове)
    * [Изходни файлове](#Изходни-файлове)
  * [Спецификатори за достъп](#Спецификатори-за-достъп)
    * [public](#public)
    * [protected](#protected)
    * [private](#private)
* [Предефиниране на оператори](#Предефиниране-на-оператори)
  * [Приятелски функции](#Приятелски-функции)
  * [Инициализиращ оператор](#Инициализиращ-оператор)
  * [Аритметични оператори](#Аритметични-оператори)
    * [Съставни оператори](#Съставни-оператори)
  * [Оператори за сравнение](#Оператори-за-сравнение)
  * [Оператори за извеждане и въвеждане](#Оператори-за-извеждане-и-въвеждане)
  * [Оператори за индексиране](#Оператори-за-индексиране)
* [Голямата четворка](#Голямата-четворка)
  * [Конструктор](#Конструктор)
  * [Копиращ конструктор](#Копиращ-конструктор)
  * [operator=](#operator=)
  * [Деструктор](#Деструктор)
* [Задачи](#Задачи)

## Принципи на обектно-ориентираното програмиране

### Енкапсулация
За околният свят на даден обект не трябва да е възможно достъп до член-данните
му, т.е. разделя се описанието (интерфейса) на класа от конкретната му
реализация. Това позволява променянето на реализацията при нужда запазвайки
интерфейса на класа.

#### Селектори
Селекторите са член-функции позволяващи преглед на член-данните, без
да ги променят. Обикновено са константни, за да се покаже експлицитно, че
промяна няма да има. Getter-ите са такива член-функции, които връщат стойността
на конкретна член-данна. Getter-ите са селектори, но не всички селектори са
getter-и, т.е. всяка публична член-функция даваща информация за състоянието на
текущия обект може да се нарече селектор.

#### Мутатори
Мутаторите (setter-и) са член-функции позволяващи промяна на член-данните като
скриват как точно променят член-данните.

### Абстракция с данни
Абстракцията с данни и енкапсулацията са много тясно свързани, тъй като
абстракцията с най-прости думи е създаването на класове и типове спрямо техните
интерфейси и функционалности, а не спрямо имлементационните им детайли, т.е.
един софтуерен обект всъщност да е модел на обект от реалния свят и да притежава
минимум основните характеристики и възможности на този обект.

### Наследяване

### Полиморфизъм

## Класове

### Разлики между класове и структури
* Класовете по продразбиране са капсулирани (спецификаторът за достъп в тялото е
  [private](#private), докато на структурата е [public](#public))

*Offtopic:* Както стана ясно в предното упражнение, ключовата дума `class` е
използвана в миналото за деклариране на шаблони, а `struct` не.

### Организация на файловете

#### Заглавни файлове (*.h)
Интерфейсът на класа се записва във заглавен (header) файл. Това включва
дефиниции на структури и класове, декларации на функции и методи. Включват се и
полетата на типа, тъй като компилаторът трябва да знае колко памет замеат
променливите от дефинирания тип, за да може да определи пълният размер на типа.

Интерфейсът на класа трябва да се загради с "include guards": `#ifndef
<име_на_клас> #define <име_на_клас> #endif`, което служи за избягване на
повторно включване на даден клас в програмата, а оттам и грешка. Може да се
използва и `#pragma once` в Windows. [Header
Guidelines](http://www.umich.edu/~eecs381/handouts/CppHeaderFileGuidelines.pdf)

#### Изходни файлове (*.cpp)
Имплементацията на класа се записва в изходен (source) файл. Включва се
заглавният файл `#include "<име_на_клас>.h"` - използват се кавички, а не
счупени скоби, тъй като по този начин компилаторът тръгва да търси включеният
файл от текущата директори нагоре, а със счупените скоби директно търси в
системните файлове.

--

*Забележка:* При шаблонните класове има особеност при разделянето на интерфейса
от имплементацията: [Why can’t I separate the definition of my templates class
from its declaration and put it inside a .cpp
file?](https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl). Често
използвано решение е да се използва файл с разширение .tpp за имплементацията и
той да бъде включен в края на заглавния файл.

### Спецификатори за достъп

#### public
Методите (член-функциите) могат да бъдат достъпвани от външни програми чрез
инстанция на класа (обект).

#### protected
Член-данните и методите (член-функциите) могат да бъдат достъпвани извън класа,
но само от негови наследници (и то при public/protected наследяване).

#### private
Член-данните и методите (член-функциите) могат да бъдат достъпвани само от
методите на типа.

## Предефиниране на оператори 

Можем да си напишем член-функции на даден клас, които да вършат работата по
сравнение, извеждане, въвеждане, индексиране и така нататък, но при положение,
че има вече съществуващи такива е по-добре просто да предефинираме действието
им. Така дори инстанция на нашия клас започва да има една много по-интуитивна
употреба. Затова ще предефинираме (overload) различни оператори.

Нека имаме клас X.

```cpp
class X {
// ...
};
```
### Приятелски функции

Приятелските функции са такива функции, които имат достъп до protected и privat
компонентите на класа, на който са „приятели“.

### Инициализиращ оператор

*Сигнатура:* 

```cpp
X& X::operator=(const X& rhs);
```
* Подава се като аргумент константен псевдоним (дясната страна на инициализацията);
* Връща се псевдоним от лявата страна (прави се, за да се поддържа навръзване,
  т.е. a = b = c = d);
* Трябва да се направи проверка, дали `*this` и rhs не са един и същ обект.

```cpp
X& X::operator=(const X& rhs) {
    if (this != &rhs) {
    }

    return *this;
}
```

### Съставни оператори

*Сигнатура:*

```cpp
X& X::operator+=(const X& rhs);
```
```cpp
X& X::operator+=(const X& rhs) {
    // модификация на *this, реализация на събирането на член-данните на двата
    // обекта

    return *this;
}
```

### Аритметични оператори

```cpp
friend X operator+(X lhs, const X &rhs);
```

```cpp
X operator+(X lhs, const X& rhs) {
    // използваме вече дефинираният оператор +=
    lhs += rhs;
    return lhs;
}
```

### Оператори за сравнение

Тези оператори е хубаво да се имплементират като приятелски (или inline)
функции, също така предефинира ли се един от тях е добре всички останали да
бъдат включени, тъй като се очаква от потребителя щом може да разполага с един,
то и останалите да са налице. Реално е необходима имплементация на два от
операторите, останалите просто ги използват.

*Сигнатура:*

```cpp
friend bool operator==(const X& lhs, const X& rhs);
friend bool operator!=(const X& lhs, const X& rhs);
friend bool operator< (const X& lhs, const X& rhs);
friend bool operator> (const X& lhs, const X& rhs);
friend bool operator<=(const X& lhs, const X& rhs);
friend bool operator>=(const X& lhs, const X& rhs);
```

```cpp
bool operator==(const X& lhs, const X& rhs){ /* необходима имплементация */ }
bool operator!=(const X& lhs, const X& rhs){ return !operator==(lhs,rhs);}
bool operator< (const X& lhs, const X& rhs){ /* необходима имплементация */ }
bool operator> (const X& lhs, const X& rhs){ return  operator< (rhs,lhs); }
bool operator<=(const X& lhs, const X& rhs){ return !operator> (lhs,rhs); }
bool operator>=(const X& lhs, const X& rhs){ return !operator< (lhs,rhs); }
```

### Оператори за извеждане и въвеждане

```cpp
friend std::ostream& operator<<(std::ostream& os, const X& obj);
friend std::istream& operator>>(std::istream& is, X& obj)
```

```cpp
std::ostream& operator<<(std::ostream& os, const X& obj)
{
    // извеждане на обекта  
    return os;
}

std::istream& operator>>(std::istream& is, X& obj)
{
    // четене на обекта

    if( /* неуспешно четене на обекто от тип X*/ )
        is.setstate(std::ios::failbit);

    return is;
}
```

### Оператори за индексиране

Трябва да са дефинирани като член-функции на дадения клас. Използват се за
типове-контейнери, които под някаква форма държат поредица от елементи и
позволяват достъп до тях чрез някакъв ключ/индекс.

```cpp
value_type& operator[](index_type idx);
const value_type& operator[](index_type idx) const;
```

## Голямата четворка

За класове с динамични член-данни е необходимо да съществуват:
* Конструктор по подразбиране;
* Копиращ конструктор;
* Инициализиращ оператор;
* Деструктор.

При класовете с нединамични член-данни е достатъчно да съществува само
конструктора, всичко останало се генерира автоматично.

### Конструктор

### Копиращ конструктор

### operator=

### Деструктор

## Задачи 

1. Стек е редица от 0 или повече елементи, в която включването и изключването на елемент се осъществява в единия край на редицата (върха на стека). Да се дефинира клас, който създава стек от символи.
2. Горният клас да се направи шаблонен, т.е. да не може да държи не само символи.
3. Да се реализира с динамичен масив (т.е. трябва да се използва каноничното представяне на класа).
